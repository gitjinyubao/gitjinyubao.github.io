<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JinYuBao</title>
  
  <subtitle>生活源于奋斗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zengmanhua.cn/"/>
  <updated>2019-06-13T03:00:31.415Z</updated>
  <id>https://www.zengmanhua.cn/</id>
  
  <author>
    <name>Jin Yu Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://www.zengmanhua.cn/2019/06/13/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.zengmanhua.cn/2019/06/13/Redis持久化/</id>
    <published>2019-06-13T02:54:32.000Z</published>
    <updated>2019-06-13T03:00:31.415Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html lang="zh-cn"><br><body><br><!--done--><br><div id="home"><br>    <div id="main"><br>        <div id="mainContent"><br>            <div class="forFlow"><br><br>## 前言<br><br>在上一篇文章中，介绍了Redis的内存模型，从这篇文章开始，将依次介绍Redis高可用相关的知识&mdash;&mdash;持久化、复制(及读写分离)、哨兵、以及集群。<br><br>本文将先说明上述几种技术分别解决了Redis高可用的什么问题；然后详细介绍Redis的持久化技术，主要是RDB和AOF两种持久化方案；在介绍RDB和AOF方案时，不仅介绍其作用及操作方法，同时介绍持久化实现的一些原理细节及需要注意的问题。最后，介绍在实际使用中，持久化方案的选择，以及经常遇到的问题等。<br><br>## 目录<br><br><a href="#t1">一、Redis高可用概述</a><br><br><a href="#t2">二、Redis持久化概述</a><br><br><a href="#t3">三、RDB持久化</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t31">1. 触发条件</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t32">2. 执行流程</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t33">3. RDB文件</a><br><br>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<a href="#t34">4. 启动时加载</a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<a href="#t35">5. <!--[endif]--><span lang="EN-US">RDB常用配置总结</span></a></span><br><br><a href="#t4"><span lang="EN-US">四、AOF持久化</span></a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t41">1. <!--[endif]-->开启<span lang="EN-US">AOF</span></a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t42">2. <!--[endif]-->执行流程</a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t43">3. <!--[endif]-->启动时加载</a></span><br><br><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t44">4. <!--[endif]--><span lang="EN-US">AOF常用配置总结</span></a></span><br><br><a href="#t5">五、方案选择与常见问题</a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t51">1. <!--[endif]--><span lang="EN-US">RDB和<span lang="EN-US">AOF的优缺点</span></span></a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t52">2. <!--[endif]-->持久化策略选择</a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t53">3. <!--[endif]--><span lang="EN-US">fork阻塞：<span lang="EN-US">CPU的阻塞</span></span></a></span><br><br><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t54">4.AOF追加阻塞：硬盘的阻塞</a></span></span></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t55">5. <!--[endif]--><span lang="EN-US">info命令与持久化</span></a></span><br><br><a href="#t6">六、总结</a><br><br># <a name="t1"></a>一、Redis高可用概述<br><br>在介绍Redis高可用之前，先说明一下在Redis的语境中高可用的含义。<br><br>我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。<br><br>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。<br><br>1.  持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。<br>2.  复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。<br>3.  哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。<br>4.  集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。<br><br># <a name="t2"></a>二、Redis持久化概述<br><br>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。<br><br>Redis持久化分为RDB持久化和AOF持久化<strong>：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；</strong>由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。<br><br>下面依次介绍RDB持久化和AOF持久化；由于Redis各个版本之间存在差异，如无特殊说明，以Redis3.0为准。<br><br># <a name="t3"></a>三、RDB持久化<br><br>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。<br><br>## <a name="t31"></a>1. 触发条件<br><br>RDB持久化的触发分为手动触发和自动触发两种。<br><br>### 1) 手动触发<br><br>save命令和bgsave命令都可以生成RDB文件。<br><br>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085242889-137050862.png" alt><br><br>而bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085309364-1576452765.png" alt><br><br>此时服务器执行日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085325656-76060516.png" alt><br><br>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。<br><br>### 2) 自动触发<br><br><strong>save m n</strong><br><br>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。<br><br>例如，查看redis的默认配置文件(Linux下为redis根目录下的redis.conf)，可以看到如下配置信息：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085420533-1928501600.png" alt><br><br>其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。<br><br><strong>save m n的实现原理</strong><br><br>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。<br><br>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。<br><br>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。<br><br>例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。<br><br>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。<br><br>save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：<br><br>（1）当前时间-lastsave &gt; m<br><br>（2）dirty &gt;= n<br><br><strong>save m n 执行日志</strong><br><br>下图是save m n触发bgsave执行时，服务器打印日志的情况：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085606524-1682958341.png" alt><br><br><strong>其他自动触发机制</strong><br><br>除了save m n 以外，还有一些其他情况会触发bgsave：<br><br><em>   在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点</em>   执行shutdown命令时，自动执行rdb持久化，如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085620830-1223048825.png" alt><br><br>## <a name="t32"></a>2. 执行流程<br><br>前面介绍了触发bgsave的条件，下面将说明bgsave命令的执行流程，如下图所示(图片来源：<a href="https://blog.csdn.net/a1007720052/article/details/79126253)：" target="_blank" rel="noopener">https://blog.csdn.net/a1007720052/article/details/79126253)：</a><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085813461-389677620.png" alt><br><br>图片中的5个步骤所进行的操作如下：<br><br>1)&nbsp; Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。<br><br>2)&nbsp; 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令<br><br>3)&nbsp; 父进程fork后，bgsave命令返回&rdquo;Background saving started&rdquo;信息并不再阻塞父进程，并可以响应其他命令<br><br>4)&nbsp; 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换<br><br>5)&nbsp; 子进程发送信号给父进程表示完成，父进程更新统计信息<br><br>## <a name="t33"></a>3. RDB文件<br><br>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。<br><br><strong>存储路径</strong><br><br>RDB文件的存储路径既可以在启动前配置，也可以通过命令动态设定。<br><br>配置：dir配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。<br><br>动态设定：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为config set dir {newdir}和config set dbfilename {newFileName}。如下所示(Windows环境)：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090102836-284073324.png" alt><br><br><strong>RDB文件格式</strong><br><br>RDB文件格式如下图所示（图片来源：《Redis设计与实现》）：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090115749-1746859283.png" alt><br><br>其中各个字段的含义说明如下：<br><br>1)&nbsp; REDIS：常量，保存着&rdquo;REDIS&rdquo;5个字符。<br><br>2)&nbsp; db_version：RDB文件的版本号，注意不是Redis的版本号。<br><br>3)&nbsp; SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。<br><br>4)&nbsp; EOF：常量，标志RDB文件正文内容结束。<br><br>5)&nbsp; check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。<br><br><strong>压缩</strong><br><br>Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090239365-13188208.png" alt><br><br>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。<br><br>## <a name="t34"></a>4. 启动时加载<br><br>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。<br><br>Redis启动日志中可以看到自动载入的执行：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090316297-2056098245.png" alt><br><br>Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。<br><br>## <a name="t35"></a>5. RDB常用配置总结<br><br>下面是RDB常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。<br><br><em>   save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发</em>   stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no<br><em>   rdbcompression yes：是否开启RDB文件压缩</em>   rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现<br><em>   dbfilename dump.rdb：RDB文件名</em>   dir ./：RDB文件和AOF文件所在目录<br><br># <a name="t4"></a>四、AOF持久化<br><br>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。<br><br>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。<br><br>## <a name="t41"></a>1. 开启AOF<br><br>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：<br><br>appendonly yes<br><br>## <a name="t42"></a>2. 执行流程<br><br>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。<br><br>AOF的执行流程包括：<br><br><em>   命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；</em>   文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；<br><em>   文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。<br><br>### 1) 命令追加(append)<br><br>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。<br><br>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。<br><br>### 2) 文件写入(write)和文件同步(sync)<br><br>Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：<br><br>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。<br><br>&nbsp;<br><br>AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：</em>   always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。<br><em>   no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</em>   everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<strong><span style="line-height: 1.5;">everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。</span></strong><br><br>### 3) 文件重写(rewrite)<br><br>随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。<br><br>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，<strong>AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</strong><br><br>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。<br><br>&nbsp;<br><br>文件重写之所以能够压缩AOF文件，原因在于：<br><br><em>   过期的数据不再写入文件</em>   无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等<br><em>   多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091657431-1777000468.png" alt><br><br>通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。<br><br><strong>文件重写的触发</strong><br><br>文件重写的触发，分为手动触发和自动触发：<br><br>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091720655-1144425871.png" alt><br><br>此时服务器执行日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091728855-1220695695.png" alt><br><br>&nbsp;<br><br>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。</em>   auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。<br><em>   auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。<br><br>其中，参数可以通过config get命令查看：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091826619-1149439298.png" alt><br><br>状态可以通过info persistence查看：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091913978-93129453.png" alt><br><br><span style="line-height: 1.5;">只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</span><br><br>自动触发bgrewriteaof时，可以看到服务器日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091932313-1279644027.png" alt><br><br><strong>文件重写的流程</strong><br><br>文件重写流程如下图所示(图片来源：<a href="http://www.cnblogs.com/yangmingxianshen/p/8373205.html)：" target="_blank" rel="noopener">http://www.cnblogs.com/yangmingxianshen/p/8373205.html)：</a><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605092001589-1724580361.png" alt><br><br>关于文件重写的流程，有两点需要特别注意：(1)重写由父进程fork子进程进行；(2)重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了aof_rewrite_buf缓存。<br><br>对照上图，文件重写的流程如下：<br><br>1) Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br><br>2) 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。<br><br>3.1) 父进程fork后，bgrewriteaof命令返回&rdquo;Background append only file rewrite started&rdquo;信息并不再阻塞父进程，并可以响应其他命令。<strong>Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。</strong><br><br>3.2) 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。<strong>由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</strong><br><br>4) 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。<br><br>5.1) 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。<br><br>5.2) 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br><br>5.3) 使用新的AOF文件替换老文件，完成AOF重写。<br><br>## <a name="t43"></a>3. 启动时加载<br><br>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。<br><br>当AOF开启，且AOF文件存在时，Redis启动日志：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125715427-372924099.png" alt><br><br>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)，Redis启动日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125726244-1151986629.png" alt><br><br><strong>文件校验</strong><br><br>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125752302-1021481114.png" alt><br><br><strong>伪客户端</strong><br><br>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。<br><br>## <a name="t44"></a>4. AOF常用配置总结<br><br>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</em>   appendonly no：是否开启AOF<br><em>   appendfilename “appendonly.aof”：AOF文件名</em>   dir ./：RDB文件和AOF文件所在目录<br><em>   appendfsync everysec：fsync持久化策略</em>   no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡<br><em>   auto-aof-rewrite-percentage 100：文件重写触发条件之一</em>   auto-aof-rewrite-min-size 64mb：文件重写触发提交之一<br><em>   aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件<br><br># <a name="t5"></a>五、方案选择与常见问题<br><br>前面介绍了RDB和AOF两种持久化方案的细节，下面介绍RDB和AOF的特点、如何选择持久化方案，以及在持久化过程中常遇到的问题等。<br><br>## <a name="t51"></a>1. RDB和AOF的优缺点<br><br>RDB和AOF各有优缺点：<br><br><strong>RDB持久化</strong><br><br>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。<br><br>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。<br><br><strong>AOF持久化</strong><br><br>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。<br><br>## <a name="t52"></a>2. 持久化策略选择<br><br>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。<br><br>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。<br><br>&nbsp;<br><br>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。<br><br>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。<br><br>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。<br><br>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。<br><br>在这种情况下，一种可行的做法是：<br><br>master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好<br><br>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。<br><br>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</em>   master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。<br><em>   master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免&ldquo;自动拉起机制&rdquo;和&ldquo;不做持久化&rdquo;同时出现。<br><br>（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。<br><br>## <a name="t53"></a>3. fork阻塞：CPU的阻塞<br><br>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：</em>   当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；<br><em>   当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；</em>   以及持久化过程中的fork操作，下面详细说明。<br><br>首先说明一下fork操作：<br><br>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。<br><br>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。<br><br>&nbsp;<br><br>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。<br><br>对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。<br><br>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。<br><br>## <a name="t54"></a>4. AOF追加阻塞：硬盘的阻塞<br><br>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。<br><br>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。<br><br>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。<br><br>&nbsp;<br><br>AOF追加阻塞问题定位的方法：<br><br>（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。<br><br>（2）AOF阻塞时的Redis日志：<br><br>Asynchronous&nbsp;AOF&nbsp;fsync&nbsp;is&nbsp;taking&nbsp;too&nbsp;long&nbsp;(disk&nbsp;is&nbsp;busy?).&nbsp;Writing&nbsp;the&nbsp;AOF&nbsp;buffer&nbsp;without&nbsp;waiting&nbsp;for&nbsp;fsync&nbsp;to&nbsp;complete,&nbsp;this&nbsp;may&nbsp;slow&nbsp;down&nbsp;Redis.<br><br>（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。<br><br>## <a name="t55"></a>5. info命令与持久化<br><br>前面提到了一些通过info命令查看持久化相关状态的方法，下面来总结一下。<br><br>（1）info Persistence<br><br>执行结果如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605131816242-1924276636.png" alt><br><br>其中比较重要的包括：<br><br><em>   rdb_last_bgsave_status:上次bgsave 执行结果，可以用于发现bgsave错误</em>   rdb_last_bgsave_time_sec:上次bgsave执行时间（单位是s），可以用于发现bgsave是否耗时过长<br><em>   aof_enabled:AOF是否开启</em>   aof_last_rewrite_time_sec: 上次文件重写执行时间（单位是s），可以用于发现文件重写是否耗时过长<br><em>   aof_last_bgrewrite_status: 上次bgrewrite执行结果，可以用于发现bgrewrite错误</em>   aof_buffer_length和aof_rewrite_buffer_length:aof缓存区大小和aof重写缓冲区大小<br>*   aof_delayed_fsync:AOF追加阻塞情况的统计<br><br>（2）info stats<br><br>其中与持久化关系较大的是：latest_fork_usec，代表上次fork耗时，可以参见前面的讨论。<br><br># <a name="t6"></a>六、总结<br><br>本文主要内容可以总结如下：<br><br>1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。<br><br>2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。<br><br>3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。<br><br>4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。<br><br># 参考文献<br><br>《Redis开发与运维》<br><br>《Redis设计与实现》<br><br>《Redis实战》<br><br><a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">http://www.redis.cn/topics/persistence.html</a><br><br><a href="https://mp.weixin.qq.com/s/fpupqLp-wjR8fQvYSQhVLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fpupqLp-wjR8fQvYSQhVLg</a><br><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650764050&amp;idx=1&amp;sn=891287b9f99a8c1dd4ce9e1805646741&amp;chksm=f3f9c687c48e4f91c6631e7f5e36a9169c10549386bec541dbeef92ed0023a373f6ec25c2ef1&amp;mpshare=1&amp;scene=1&amp;srcid=0525xnHQxiFwpzFWSME2LQrb#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650764050&amp;idx=1&amp;sn=891287b9f99a8c1dd4ce9e1805646741&amp;chksm=f3f9c687c48e4f91c6631e7f5e36a9169c10549386bec541dbeef92ed0023a373f6ec25c2ef1&amp;mpshare=1&amp;scene=1&amp;srcid=0525xnHQxiFwpzFWSME2LQrb#rd</a><br><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650763383&amp;idx=1&amp;sn=348a84605a7cdefe4e075c9f0310f257&amp;chksm=f3f9c5e2c48e4cf41bd3f708bce3f9a1302a699cf7defe611e9aea120fcb424944119e079362&amp;mpshare=1&amp;scene=1&amp;srcid=0525XIl8KXvHYvX42oaUcop0#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650763383&amp;idx=1&amp;sn=348a84605a7cdefe4e075c9f0310f257&amp;chksm=f3f9c5e2c48e4cf41bd3f708bce3f9a1302a699cf7defe611e9aea120fcb424944119e079362&amp;mpshare=1&amp;scene=1&amp;srcid=0525XIl8KXvHYvX42oaUcop0#rd</a><br><br><a href="https://blog.csdn.net/tonyxf121/article/details/8475603" target="_blank" rel="noopener">https://blog.csdn.net/tonyxf121/article/details/8475603</a><br><br><a href="http://heylinux.com/archives/1932.html" target="_blank" rel="noopener">http://heylinux.com/archives/1932.html</a><br><br><a href="https://www.m690.com/archives/380/" target="_blank" rel="noopener">https://www.m690.com/archives/380/</a><br>            </div><!--end: forFlow --><br>        </div><!--end: mainContent 主体内容容器--><br>        <div class="clear"></div><br>    </div><!--end: main --><br>    <div class="clear"></div><br></div><!--end: home 自定义的最大容器 --><br><br></body><br></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;html lang=&quot;zh-cn&quot;&gt;&lt;br&gt;&lt;body&gt;&lt;br&gt;&lt;!--done--&gt;&lt;br&gt;&lt;div id=&quot;home&quot;&gt;&lt;br&gt;    &lt;div id=&quot;main&quot;&gt;&lt;br&gt;        &lt;div id=&quot;main
      
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="redis系统深入学习" scheme="https://www.zengmanhua.cn/tags/redis%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存模型</title>
    <link href="https://www.zengmanhua.cn/2019/06/13/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.zengmanhua.cn/2019/06/13/Redis内存模型/</id>
    <published>2019-06-13T02:24:23.000Z</published>
    <updated>2019-06-13T02:55:51.188Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html lang="zh-cn"><br><body><br><!--done--><br><div id="home"><br><br>## 前言<br><br>Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。<br><br>我们使用Redis时，会接触Redis的5种对象类型（字符串、哈希、列表、集合、有序集合），丰富的类型是Redis相对于Memcached等的一大优势。在了解Redis的5种对象类型的用法和特点的基础上，进一步了解Redis的内存模型，对Redis的使用有很大帮助，例如：<br><br>1、估算Redis内存使用量。目前为止，内存的使用成本仍然相对较高，使用内存不能无所顾忌；根据需求合理的评估Redis的内存使用量，选择合适的机器配置，可以在满足需求的情况下节约成本。<br><br>2、优化内存占用。了解Redis内存模型可以选择更合适的数据类型和编码，更好的利用Redis内存。<br><br>3、分析解决问题。当Redis出现阻塞、内存占用等问题时，尽快发现导致问题的原因，便于分析解决问题。<br><br>这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。<br><br>在后面的文章中，会陆续介绍关于Redis高可用的内容，包括主从复制、哨兵、集群等等，欢迎关注。<br><br>## 系列文章<br><br><a href="https://www.cnblogs.com/kismetv/p/8654978.html" target="_blank" rel="noopener">深入学习Redis（1）：Redis内存模型</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a><br><br>## 目录<br><br><a href="#t1">一、Redis内存统计</a><br><br><a href="#t2">二、Redis内存划分</a><br><br>　　<a href="#t21">1、数据（或者称为对象）</a><br><br>　　<a href="#t22">2、进程本身运行需要的内存</a><br><br>　　<a href="#t23">3、缓冲内存</a><br><br>　　<a href="#t24">4、内存碎片</a><br><br><a href="#t3">三、Redis数据存储的细节</a><br><br>　　<a href="#t31">1、概述</a><br><br>　　<a href="#t32">2、jemalloc</a><br><br>　　<a href="#t33">3、redisObject</a><br><br>　　<a href="#t34">4、SDS</a><br><br><a href="#t4">四、Redis的对象类型与内部编码</a><br><br>　　<a href="#t41">1、字符串</a><br><br>　　<a href="#t42">2、列表</a><br><br>　　<a href="#t43">3、哈希</a><br><br>　　<a href="#t44">4、集合</a><br><br>　　<a href="#t45">5、有序集合</a><br><br><a href="#t5">五、应用举例</a><br><br>　　<a href="#t51">1、估算Redis内存使用量</a><br><br>　　<a href="#t52">2、优化内存占用</a><br><br>　　<a href="#t53">3、关注内存碎片率</a><br><br><a href="#t6">六、参考文献</a><br><br># <a name="t1"></a>一、Redis内存统计<br><br>工欲善其事必先利其器，在说明Redis内存之前首先说明如何统计Redis使用内存的情况。<br><br>在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:bash;gutter:true;">info memory</pre><br></div><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327000947752-2103814952.png" alt><br><br>其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。<br><br>返回结果中比较重要的几个说明如下：<br><br>（1）<strong>used_memory**</strong>：<strong>Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。<br><br>（2）</strong>used_memory_rss<strong>**：</strong>Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。<br><br>因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。<br><br>由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。<br><br>（3）<strong>mem_fragmentation_ratio**</strong>：<strong>内存碎片比率，该值是used_memory_rss / used_memory的比值。<br><br>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。<br><br>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；上面截图中的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。<br><br>（4）</strong>mem_allocator<strong>**：</strong>Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。<br><br># <a name="t2"></a>二、Redis内存划分<br><br>Redis作为内存数据库，在内存中存储的内容主要是数据（键值对）；通过前面的叙述可以知道，除了数据以外，Redis的其他部分也会占用内存。<br><br>Redis的内存占用主要可以划分为以下几个部分：<br><br>## <a name="t21"></a>1、数据<br><br>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。<br><br>Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。<br><br>## <a name="t22"></a>2、进程本身运行需要的内存<br><br>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。<br><br>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。<br><br>## <a name="t23"></a>3、缓冲内存<br><br>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。<br><br>## <a name="t24"></a>4、内存碎片<br><br>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。<br><br>内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。<br><br>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。<br><br># <a name="t3"></a>三、Redis数据存储的细节<br><br>## <a name="t31"></a>1、概述<br><br>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。<br><br>下图是执行set hello world时，所涉及到的数据模型。<br><br>&nbsp;<img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001055927-1896197804.png" alt><br><br>图片来源：<a href="https://searchdatabase.techtarget.com.cn/7-20218/" target="_blank" rel="noopener">https://searchdatabase.techtarget.com.cn/7-20218/</a><br><br>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。<br><br>（2）Key：图中右上角可见，Key（&rdquo;hello&rdquo;）并不是直接以字符串存储，而是存储在SDS结构中。<br><br>（3）redisObject：Value(&ldquo;world&rdquo;)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。<br><br>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。<br><br>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。<br><br>下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。<br><br>## <a name="t32"></a>2、jemalloc<br><br>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。<br><br>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。<br><br>jemalloc划分的内存单元如下图所示：<br><br>&nbsp;<img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt><br><br><span style="line-height: 1.5;">图片来源：<a href="http://blog.csdn.net/zhengpeitao/article/details/76573053" target="_blank" rel="noopener">http://blog.csdn.net/zhengpeitao/article/details/76573053</a></span><br><br>例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。<br><br>## <a name="t33"></a>3、redisObject<br><br>前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。<br><br>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。<br><br>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct redisObject {<br>　　unsigned type:4;<br>　　unsigned encoding:4;<br>　　unsigned lru:REDIS_LRU_BITS; /<em> lru time (relative to server.lruclock) </em>/<br>　　int refcount;<br>　　void <em>ptr;<br>} robj;</em></pre><br></div><br><br>redisObject的每个字段的含义和作用如下：<br><br>### （1）type<br><br>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。<br><br>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001214189-1733420705.png" alt><br><br>### （2）encoding<br><br>encoding表示对象的内部编码，占4个比特。<br><br>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。<br><br>通过object encoding命令，可以查看对象采用的编码方式，如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001228807-998910409.png" alt><br><br>5种对象类型对应的编码方式以及使用条件，将在后面介绍。<br><br>### （3）lru<br><br>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。<br><br>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001239788-1325383307.png" alt><br><br>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys&mdash;lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。<br><br>### （4）refcount<br><br><strong>refcount**</strong>与共享对象<strong><br><br>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。<br><br>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。</strong>共享对象的具体实现**<br><br>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。<br><br>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。<br><br>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0~9999的整数值；当Redis需要使用值为0~9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。<br><br>共享对象的引用次数可以通过object refcount命令查看，如下图所示。命令执行的结果页佐证了只有0~9999之间的整数会作为共享对象。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001256958-1309209644.png" alt><br><br>### （5）ptr<br><br>ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。<br><br>### （6）总结<br><br>综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：<br><br>4bit+4bit+24bit+4Byte+8Byte=16Byte。<br><br>## <a name="t34"></a>4、SDS<br><br>Redis没有直接使用C字符串(即以空字符&rsquo;\0&rsquo;结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。<br><br>### （1）SDS结构<br><br>sds的结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">struct sdshdr {<br>    int len;<br>    int free;<br>    char buf[];<br>};</pre><br></div><br><br>其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001321434-1043595793.png" alt><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001325561-890602831.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。<br><br>### （2）SDS与C字符串的比较<br><br>SDS在C字符串的基础上加入了free和len字段，带来了很多好处：   获取字符串长度：SDS是O(1)，C字符串是O(n)<br><em>   缓冲区溢出：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</em>   修改字符串时内存的重分配：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化：空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。<br><em>   存取二进制数据：SDS可以，C字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。<br><br>此外，由于SDS中的buf仍然使用了C字符串（即以&rsquo;\0&rsquo;结尾），因此SDS可以使用C字符串库中的部分函数；但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（&rsquo;\0&rsquo;不一定是结尾）。<br><br>### （3）SDS与C字符串的应用<br><br>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（&rdquo;myset&rdquo;），还是集合中的元素（&rdquo;member1&rdquo;、 &rdquo;member2&rdquo;和&rdquo;member3&rdquo;），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。<br><br>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。<br><br># <a name="t4"></a>四、Redis的对象类型与内部编码<br><br>前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。<br><br>Redis各种对象类型支持的内部编码如下图所示(图中版本是Redis3.0，Redis后面版本中又增加了内部编码，略过不提；本章所介绍的内部编码都是基于3.0的)：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001358239-1304238510.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>关于Redis内部编码的转换，都符合以下规律：<strong>编码转换在**</strong>Redis<strong>**写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</strong><br><br>## <a name="t41"></a>1、字符串<br><br>### （1）概况<br><br>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。<br><br>字符串长度不能超过512MB。<br><br>### （2）内部编码<br><br>字符串类型的内部编码有3种，它们的应用场景如下：</em>   int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。<br><em>   embstr：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</em>   raw：大于39个字节的字符串<br><br>示例如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001417703-15851809.png" alt><br><br>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。<br><br>### （3）编码转换<br><br>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。<br><br>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。示例如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001426651-1225081171.png" alt><br><br>## <a name="t42"></a>2、列表<br><br>### （1）概况<br><br>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。<br><br>### （2）内部编码<br><br>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。<br><br>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001435577-242733744.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。<br><br>&nbsp;<br><br>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的<strong>连续内存块</strong>(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。<br><br>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。<br><br>下图展示了列表编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001457636-673470263.png" alt><br><br>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。<br><br>## <a name="t43"></a>3、哈希<br><br>### （1）概况<br><br>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用&ldquo;内层的哈希&rdquo;时，代表的是redis对外提供的5种对象类型的一种；使用&ldquo;外层的哈希&rdquo;代指Redis作为Key-Value数据库所使用的数据结构。<br><br>### （2）内部编码<br><br>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。<br><br>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。<br><br>&nbsp;<br><br>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。<br><br>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001627028-325473621.png" alt>&nbsp;<br><br>图片改编自：《Redis设计与实现》<br><br>下面从底层向上依次介绍各个部分：<br><br><strong>dictEntry</strong><br><br>dictEntry结构用于保存键值对，结构定义如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dictEntry{<br>    void <em>key;<br>    union{<br>        void </em>val;<br>        uint64_tu64;<br>        int64_ts64;<br>    }v;<br>    struct dictEntry <em>next;<br>}dictEntry;</em></pre><br></div><br><br>其中，各个属性的功能如下：   key：键值对中的键；<br><em>   val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；</em>   next：指向下一个dictEntry，用于解决哈希冲突问题<br><br>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。<br><br><strong>bucket</strong><br><br>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。<br><br><strong>dictht</strong><br><br>dictht结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dictht{<br>    dictEntry <strong>table;<br>    unsigned long size;<br>    unsigned long sizemask;<br>    unsigned long used;<br>}dictht;</strong></pre><br></div><br><br>其中，各个属性的功能说明如下：<br><br><em>   table属性是一个指针，指向bucket；</em>   size属性记录了哈希表的大小，即bucket的大小；<br><em>   used记录了已使用的dictEntry的数量；</em>   sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。dict*<em><br><br>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。<br><br>dict结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dict{<br>    dictType </pre></div></em>type;<br>    void <em>privdata;<br>    dictht ht[2];<br>    int trehashidx;<br>} dict;<br></em></div><br><br>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。<br><br>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。<br><br>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。<br><br>### （3）编码转换<br><br>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。<br><br>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。<br><br>下图展示了Redis内层的哈希编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001855681-1566128865.png" alt><br><br>## <a name="t44"></a>4、集合<br><br>### （1）概况<br><br>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。<br><br>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。<br><br>### （2）内部编码<br><br>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。<br><br>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。<br><br>整数集合的结构定义如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct intset{<br>    uint32_t encoding;<br>    uint32_t length;<br>    int8_t contents[];<br>} intset;</pre><br></div><br><br>其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。<br><br>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于集合数量较少，因此操作的时间并没有明显劣势。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。<br><br>下图展示了集合编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001926146-2105183556.png" alt><br><br>## <a name="t45"></a>5、有序集合<br><br>### （1）概况<br><br>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。<br><br>### （2）内部编码<br><br>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。<br><br>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。<br><br>下图展示了有序集合编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001936290-955216194.png" alt><br><br># <a name="t5"></a>五、应用举例<br><br>了解Redis的内存模型之后，下面通过几个例子说明其应用。<br><br>## <a name="t51"></a>1、估算Redis内存使用量<br><br>要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。<br><br>下面以最简单的字符串类型来进行说明。<br><br>假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。<br><br>90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。<br><br>每个dictEntry占据的空间包括：<br><br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个dictEntry，24字节，jemalloc会分配32字节的内存块<br><br>2) &nbsp; &nbsp; &nbsp;&nbsp;一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块<br><br>3) &nbsp; &nbsp; &nbsp;&nbsp;一个redisObject，16字节，jemalloc会分配16字节的内存块<br><br>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块<br><br>5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 综上，一个dictEntry需要32+16+16+16=80个字节。<br><br>bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。<br><br>因此，可以估算出这90000个键值对占据的内存大小为：9000080 + 131072<em>8 = 8248576。<br><br>下面写个程序在redis中验证一下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">public class RedisTest {<br><br>　　public static Jedis jedis = new Jedis(“localhost”, 6379);<br><br>　　public static void main(String[] args) throws Exception{<br>　　　　Long m1 = Long.valueOf(getMemory());<br>　　　　insertData();<br>　　　　Long m2 = Long.valueOf(getMemory());<br>　　　　System.out.println(m2 - m1);<br>　　}<br><br>　　public static void insertData(){<br>　　　　for(int i = 10000; i &lt; 100000; i++){<br>　　　　　　jedis.set(“aa” + i, “aa” + i); //key和value长度都是7字节，且不是整数<br>　　　　}<br>　　}<br><br>　　public static String getMemory(){<br>　　　　String memoryAllLine = jedis.info(“memory”);<br>　　　　String usedMemoryLine = memoryAllLine.split(“\r\n”)[1];<br>　　　　String memory = usedMemoryLine.substring(usedMemoryLine.indexOf(‘:’) + 1);<br>　　　　return memory;<br>　　}<br>}</pre><br></div><br><br>运行结果：8247552<br><br>理论值与结果值误差在万分之1.2，对于计算需要多少内存来说，这个精度已经足够了。之所以会存在误差，是因为在我们插入90000条数据之前redis已分配了一定的bucket空间，而这些bucket空间尚未使用。<br><br>&nbsp;<br><br>作为对比将key和value的长度由7字节增加到8字节，则对应的SDS变为17个字节，jemalloc会分配32个字节，因此每个dictEntry占用的字节数也由80字节变为112字节。此时估算这90000个键值对占据内存大小为：90000</em>112 + 131072*8 = 11128576。<br><br>在redis中验证代码如下（只修改插入数据的代码）：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">public static void insertData(){<br>　　for(int i = 10000; i &lt; 100000; i++){<br>　　　　jedis.set(“aaa” + i, “aaa” + i); //key和value长度都是8字节，且不是整数<br>　　}<br>}</pre><br></div><br><br>运行结果：11128576；估算准确。<br><br>&nbsp;<br><br>对于字符串类型之外的其他类型，对内存占用的估算方法是类似的，需要结合具体类型的编码方式来确定。<br><br>## <a name="t52"></a>2、优化内存占用<br><br>了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。<br><br>（1）利用jemalloc特性进行优化<br><br>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。<br><br>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。<br><br>（2）使用整型/长整型<br><br>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。<br><br>（3）共享对象<br><br>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。<br><br>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。<br><br>（4）避免过度设计<br><br>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。<br><br>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。<br><br>## <a name="t53"></a>3、关注内存碎片率<br><br>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。<br><br>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。<br><br>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。<br><br>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。<br><br># <a name="t6"></a>六、参考文献<br><br>《Redis开发与运维》<br><br>《Redis设计与实现》<br><br><a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a><br><br><a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a><br><br><a href="https://www.cnblogs.com/lhcpig/p/4769397.html" target="_blank" rel="noopener">https://www.cnblogs.com/lhcpig/p/4769397.html</a><br><br><a href="https://searchdatabase.techtarget.com.cn/7-20218/" target="_blank" rel="noopener">https://searchdatabase.techtarget.com.cn/7-20218/</a><br><br><a href="http://www.cnblogs.com/mushroom/p/4738170.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4738170.html</a><br><br><a href="http://www.imooc.com/article/3645" target="_blank" rel="noopener">http://www.imooc.com/article/3645</a><br><br><a href="http://blog.csdn.net/zhengpeitao/article/details/76573053" target="_blank" rel="noopener">http://blog.csdn.net/zhengpeitao/article/details/76573053</a><br></body><br></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;html lang=&quot;zh-cn&quot;&gt;&lt;br&gt;&lt;body&gt;&lt;br&gt;&lt;!--done--&gt;&lt;br&gt;&lt;div id=&quot;home&quot;&gt;&lt;br&gt;&lt;br&gt;## 前言&lt;br&gt;&lt;br&gt;Redis是目前最火爆的内存数据库之一，通过在内存中读
      
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="reids系统深入学习" scheme="https://www.zengmanhua.cn/tags/reids%E7%B3%BB%E7%BB%9F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.zengmanhua.cn/2019/05/31/hello-world/"/>
    <id>https://www.zengmanhua.cn/2019/05/31/hello-world/</id>
    <published>2019-05-30T23:50:54.336Z</published>
    <updated>2019-06-11T04:28:08.533Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p8.jpg" alt></p><h3 id="welcome-here"><a href="#welcome-here" class="headerlink" title="welcome here !"></a>welcome here !</h3><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p8.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;welcome-here&quot;&gt;&lt;a href=&quot;#welcome-here&quot; class=&quot;headerlink&quot; title=&quot;welcome here !&quot;&gt;&lt;/a&gt;welcome here !&lt;/h3&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.zengmanhua.cn/categories/life/"/>
    
    
      <category term="生活" scheme="https://www.zengmanhua.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal及ThreadLocal内存溢出分析</title>
    <link href="https://www.zengmanhua.cn/2019/05/24/ThreadLocal%E5%8F%8AThreadLocal%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>https://www.zengmanhua.cn/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/</id>
    <published>2019-05-24T05:21:05.000Z</published>
    <updated>2019-06-11T04:28:37.184Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p15.jpg" alt></p><h3 id="ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露"><a href="#ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露" class="headerlink" title="ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)"></a>ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)</h3><p>ThreadLocal 也可以跟踪一个请求，从接收请求，处理请求，到返回请求，只要线程不销毁，就可以在线程的任何地方，调用这个参数，这是百度二面的题目，参考：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Threadlocal 传递参数(百度二面) ： https://www.cnblogs.com/aspirant/p/9183920.html</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">1. JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。</span><br><span class="line">2. JVM利用调用remove、get、set方法的时候，回收弱引用。</span><br><span class="line">3. 当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。</span><br><span class="line">4. 当使用static ThreadLocal的时候，延长ThreadLocal的生命周期，那也可能导致内存泄漏。因为，static变量在类未加载的时候，它就已经加载，当线程结束的时候，static变量不一定会回收。那么，比起普通成员变量使用的时候才加载，static的生命周期加长将更容易导致内存泄漏危机。http://www.importnew.com/22039.html</span><br></pre></td></tr></table></figure><p><strong><em>那么如何有效的避免呢？</em></strong></p><p><strong><em>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。我们也可以通过调用ThreadLocal的remove方法进行释放！</em></strong></p><p>threadlocal里面使用了一个存在弱引用的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法.</p><p>在threadlocal的生命周期中,都存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.<br><img src="http://47.103.200.134/image/b18.jpg" alt><br>每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p><p>所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，<strong><em>但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露</em></strong>.其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。<strong><em>比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。</em></strong></p><p>PS.Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。所以最怕的情况就是，threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。 </p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal &lt; Connection &gt; connectionHolder = new ThreadLocal &lt; Connection &gt; () &#123;</span><br><span class="line">    public Connection initialValue() &#123;</span><br><span class="line">        return DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">    return connectionHolder.get();</span><br><span class="line">&#125;</span><br><span class="line">private static final ThreadLocal threadSession = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">public static Session getSession() throws InfrastructureException &#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (HibernateException ex) &#123;</span><br><span class="line">        throw new InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ThreadLocal是什么？有什么用？"><a href="#ThreadLocal是什么？有什么用？" class="headerlink" title="ThreadLocal是什么？有什么用？"></a>ThreadLocal是什么？有什么用？</h4><p>引入话题：在并发条件下，如何正确获得共享数据？举例：假设有多个用户需要获取用户信息，一个线程对应一个用户。在mybatis中，session用于操作数据库，那么设置、获取操作分别是session.set()、session.get()，如何保证每个线程都能正确操作达到想要的结果？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回顾synchronized在多线程共享线程的问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qiuyongAaron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalOne</span> </span>&#123;</span><br><span class="line">     <span class="keyword">volatile</span> Person person=<span class="keyword">new</span> Person();</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> String <span class="title">setAndGet</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">          <span class="comment">//System.out.print(Thread.currentThread().getName()+":");</span></span><br><span class="line">           person.name=name;</span><br><span class="line">           <span class="comment">//模拟网络延迟</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> person.name;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           ThreadLocalOne  threadLocal=<span class="keyword">new</span> ThreadLocalOne();</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;System.out.println(threadLocal.setAndGet(<span class="string">"arron"</span>)),<span class="string">"t1"</span>).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;System.out.println(threadLocal.setAndGet(<span class="string">"tony"</span>)),<span class="string">"t2"</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     String name=<span class="string">"tom"</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.name=name;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">无synchronized：</span><br><span class="line">t1:tony</span><br><span class="line">t2:tony</span><br><span class="line"> </span><br><span class="line">有synchronized：</span><br><span class="line">t1:arron</span><br><span class="line">t2:tony</span><br></pre></td></tr></table></figure><h5 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析:"></a>步骤分析:</h5><pre><code>1. 无synchronized的时候，因为非原子操作，显然不是预想结果，可参考我关于synchronized的讨论。2. 现在，我们的需求是：每个线程独立的设置获取person信息，不被线程打扰。3. 因为，person是共享数据，用同步互斥锁synchronized，当一个线程访问共享数据的时候，其他线程堵塞，不再多余赘述。</code></pre><p>通过举例问题，可能大家又会很疑惑？<br>mybatis、hibernate是如何实现的呢？<br>synchronized不会很消耗资源，当成千上万个操作的时候，承受并发不说，数据返回延迟如何确保用户体验？</p><p>ThreadLocal是什么？有什么用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 谈谈ThreadLocal的作用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qiuyongAaron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalThree</span> </span>&#123;</span><br><span class="line">     ThreadLocal&lt;Person&gt; threadLocal=<span class="keyword">new</span> ThreadLocal&lt;Person&gt;();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">setAndGet</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">           threadLocal.set(<span class="keyword">new</span> Person(name));</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> threadLocal.get().name;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           ThreadLocalThree  threadLocal=<span class="keyword">new</span> ThreadLocalThree();</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"t1:"</span>+threadLocal.setAndGet(<span class="string">"arron"</span>)),<span class="string">"t1"</span>).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"t2:"</span>+threadLocal.setAndGet(<span class="string">"tony"</span>)),<span class="string">"t2"</span>).start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">t1:arron</span><br><span class="line">t2:tony</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>1、根据预期结果，那ThreadLocal到底是什么？<br>回顾Java内存模型：<br><img src="http://47.103.200.134/image/b19.png" alt><br> 在虚拟机中，堆内存用于存储共享数据（实例对象），堆内存也就是这里说的主内存。</p><p> 每个线程将会在堆内存中开辟一块空间叫做线程的工作内存，附带一块缓存区用于存储共享数据副本。那么，共享数据在堆内存当中，线程通信就是通过主内存为中介，线程在本地内存读并且操作完共享变量操作完毕以后，把值写入主内存。</p><pre><code>1. ThreadLocal被称为线程局部变量，说白了，他就是线程工作内存的一小块内存，用于存储数据。2. 那么，ThreadLocal.set()、ThreadLocal.get()方法，就相当于把数据存储于线程本地，取也是在本地内存读取。就不会像synchronized需要频繁的修改主内存的数据，再把数据复制到工作内存，也大大提高访问效率。</code></pre><p> 2、ThreadLocal到底有什么用？</p><pre><code>1. 回到最开始的举例，也就等价于mabatis、hibernate为什么要使用threadlocal来存储session？2. 作用一：因为线程间的数据交互是通过工作内存与主存的频繁读写完成通信，然而存储于线程本地内存，提高访问效率，避免线程阻塞造成cpu吞吐率下降。3. 作用二：在多线程中，每一个线程都需要维护session，轻易完成对线程独享资源的操作。</code></pre><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>  Threadlocal是什么？在堆内存中，每个线程对应一块工作内存，threadlocal就是工作内存的一小块内存。<br>  Threadlocal有什么用？threadlocal用于存取线程独享数据，提高访问效率。</p><h4 id="ThreadLocal源码简要总结？"><a href="#ThreadLocal源码简要总结？" class="headerlink" title="ThreadLocal源码简要总结？"></a>ThreadLocal源码简要总结？</h4><p>那有同学可能还是有点云里雾里，感觉还是没有吃透？那线程内部如何去保证线程独享数据呢？<br>在这里，我只做简要总结，若有兴趣，可参考文章尾部的文章链接。重点看get、set方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li>一个线程对应一个ThreadLocalMap ，可以存储多个ThreadLocal对象。</li><li>ThreadLocal对象作为key、独享数据作为value。</li><li>ThreadLocalMap可参考HashMap，在ThreadMap里面存在Entry数组也就是一个Entry一个键值对。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><ol><li>一个线程对应一个ThreadLocalMap，get()就是当前线程获取自己的ThreadLocalMap。</li><li>线程根据使用那一小块的threadlocal，根据ThreadLocal对象作为key，去获取存储于ThreadLocalMap中的值。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>回顾一下，我们在单线程中如何使用HashMap的？hashMap根据数组+链表来实现HashMap，一个key对应一个value。那么，我们抽象一下，Threadlocal也相当于在多线程中的一种HashMap用法，相当于对ThradLocal的操作也就如单线程操作一样。<br>总之，ThreadLocal就是堆内存的一块小内存，它用ThreadLocalMap维护ThreadLocal对象作为key，独享数据作为value的东西。</p><h4 id="ThreadLocal为什么会导致内存泄漏？"><a href="#ThreadLocal为什么会导致内存泄漏？" class="headerlink" title="ThreadLocal为什么会导致内存泄漏？"></a>ThreadLocal为什么会导致内存泄漏？</h4><p><strong><em>synchronized是用时间换空间(牺牲时间)、ThreadLocal是用空间换时间(牺牲空间)</em></strong>，为什么这么说？<br><strong><em>因为synchronized操作数据，只需要在主存存一个变量即可，就阻塞等共享变量，而ThreadLocal是每个线程都创建一块小的堆工作内存</em></strong>。显然，印证了上面的说法。</p><p>一个线程对应一块工作内存，线程可以存储多个ThreadLocal。那么假设，开启1万个线程，每个线程创建1万个ThreadLocal，也就是每个线程维护1万个ThreadLocal小内存空间，而且当线程执行结束以后，假设这些ThreadLocal里的Entry还不会被回收，那么将很容易导致堆内存溢出。</p><p>怎么办？难道JVM就没有提供什么解决方案吗？<br>ThreadLocal当然有想到，所以他们把ThreadLocal里的Entry设置为弱引用，当垃圾回收的时候，回收ThreadLocal。<br>什么是弱引用？</p><ol><li>Key使用强引用：也就是上述说的情况，引用ThreadLocal的对象被回收了，ThreadLocal的引用ThreadLocalMap的Key为强引用并没有被回收，如果不手动回收的话，ThreadLocal将不会回收那么将导致内存泄漏。</li><li>Key使用弱引用：引用的ThreadLocal的对象被回收了，<strong><em>ThreadLocal的引用ThreadLocalMap的Key为弱引用，如果内存回收，那么将ThreadLocalMap的Key将会被回收，ThreadLocal也将被回收。value在ThreadLocalMap调用get、set、remove的时候就会被清除。</em></strong></li><li>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：<strong><em>弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</em></strong></li></ol><p>那按你这么说，既然JVM有保障了，还有什么内存泄漏可言？<br>ThreadLocalMap使用ThreadLocal对象作为弱引用，当垃圾回收的时候，ThreadLocalMap中Key将会被回收，也就是将Key设置为null的Entry。<strong><em>如果线程迟迟无法结束，也就是ThreadLocal对象将一直不会回收，回顾到上面存在很多线程+TheradLocal，那么也将导致内存泄漏。(内存泄露的重点)</em></strong></p><p>其实，在ThreadLocal中，当调用remove、get、set方法的时候，会清除为null的弱引用，也就是回收ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal提供一个线程（Thread）局部变量，访问到某个变量的每一个线程都拥有自己的局部变量。说白了，ThreadLocal就是想在多线程环境下去保证成员变量的安全。</span><br></pre></td></tr></table></figure><h5 id="ThreadLocal提供的方法"><a href="#ThreadLocal提供的方法" class="headerlink" title="ThreadLocal提供的方法"></a>ThreadLocal提供的方法</h5><p><img src="http://47.103.200.134/image/b20.png" alt><br>ThreadLocal API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于ThreadLocal而言，常用的方法，就是get/set/initialValue方法。</span><br></pre></td></tr></table></figure></p><h5 id="我们先来看一个例子"><a href="#我们先来看一个例子" class="headerlink" title="我们先来看一个例子"></a>我们先来看一个例子</h5><p><img src="http://47.103.200.134/image/b21.png" alt><br><strong><em>运行结果</em></strong><br><img src="http://47.103.200.134/image/b22.png" alt><br>是你想象中的结果么？<br><strong><em>很显然，在这里，并没有通过ThreadLocal达到线程隔离的机制，可是ThreadLocal不是保证线程安全的么？这是什么鬼？</em></strong><br><strong><em>虽然，ThreadLocal让访问某个变量的线程都拥有自己的局部变量，但是如果这个局部变量都指向同一个对象呢？这个时候ThreadLocal就失效了。仔细观察下图中的代码，你会发现，threadLocal在初始化时返回的都是同一个对象a！</em></strong></p><h4 id="看一看ThreadLocal源码"><a href="#看一看ThreadLocal源码" class="headerlink" title="看一看ThreadLocal源码"></a>看一看ThreadLocal源码</h4><p>我们直接看最常用的set操作：<br><img src="http://47.103.200.134/image/b23.png" alt><br>set<br><img src="http://47.103.200.134/image/b24.png" alt><br>线程局部变量<br><img src="http://47.103.200.134/image/b25.png" alt><br>createMap</p><p>你会看到，set需要首先获得当前线程对象Thread；</p><p>然后取出当前线程对象的成员变量ThreadLocalMap；</p><p>如果ThreadLocalMap存在，那么进行KEY/VALUE设置，KEY就是ThreadLocal；</p><p>如果ThreadLocalMap没有，那么创建一个；</p><p>说白了，当前线程中存在一个Map变量，KEY是ThreadLocal，VALUE是你设置的值。</p><p>看一下get操作：<br><img src="http://47.103.200.134/image/b26.png" alt><br>get<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里其实揭示了ThreadLocalMap里面的数据存储结构，从上面的代码来看，ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值</span><br></pre></td></tr></table></figure></p><h5 id="ThreadLocalMap-Entry："><a href="#ThreadLocalMap-Entry：" class="headerlink" title="ThreadLocalMap.Entry："></a>ThreadLocalMap.Entry：</h5><p><img src="http://47.103.200.134/image/b27.png" alt><br>弱引用？<br><strong><em>在JAVA里面，存在强引用、弱引用、软引用、虚引用。这里主要谈一下强引用和弱引用。</em></strong><br>强引用，就不必说了，类似于：</p><p>A a = new A();</p><p>B b = new B();</p><p>考虑这样的情况：</p><p>C c = new C(b);</p><p>b = null;</p><p>考虑下GC的情况。要知道b被置为null，那么是否意味着一段时间后GC工作可以回收b所分配的内存空间呢？答案是否定的，因为即便b被置为null，但是c仍然持有对b的引用，而且还是强引用，所以GC不会回收b原先所分配的空间！既不能回收利用，又不能使用，这就造成了内存泄露。<br>那么如何处理呢？</p><p>可以c = null;也可以使用弱引用！（WeakReference w = new WeakReference(b);）</p><p>分析到这里，我们可以得到：<br><img src="http://47.103.200.134/image/b28.png" alt><br>内存结构图<br>这里我们思考一个问题：ThreadLocal使用到了弱引用，是否意味着不会存在内存泄露呢？ </p><p>首先来说，如果把ThreadLocal置为null，那么意味着Heap中的ThreadLocal实例不在有强引用指向，只有弱引用存在，因此GC是可以回收这部分空间的，也就是key是可以回收的。但是value却存在一条从Current Thread过来的强引用链。因此只有当Current Thread销毁时，value才能得到释放。</p><p>因此，只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间内不会被回收的，就发生了我们认为的内存泄露。最要命的是线程对象不被回收的情况，比如使用线程池的时候，线程结束是不会销毁的，再次使用的，就可能出现内存泄露。</p><p><strong><em>那么如何有效的避免呢？</em></strong></p><p><strong><em>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。我们也可以通过调用ThreadLocal的remove方法进行释放！</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：https://www.cnblogs.com/aspirant/p/8991010.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p15.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露&quot;&gt;&lt;a href=&quot;#ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)&quot;&gt;&lt;/a&gt;ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)&lt;/h3&gt;&lt;p&gt;ThreadLocal 也可以跟踪一个请求，从接收请求，处理请求，到返回请求，只要线程不销毁，就可以在线程的任何地方，调用这个参数，这是百度二面的题目，参考：&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>内存溢出&amp;&amp;栈溢出</title>
    <link href="https://www.zengmanhua.cn/2019/05/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.zengmanhua.cn/2019/05/24/内存溢出-栈溢出/</id>
    <published>2019-05-24T02:02:54.000Z</published>
    <updated>2019-06-11T04:29:32.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存溢出-amp-amp-栈溢出"><a href="#内存溢出-amp-amp-栈溢出" class="headerlink" title="内存溢出&amp;&amp;栈溢出"></a>内存溢出&amp;&amp;栈溢出</h3><p><img src="http://47.103.200.134/image/p5.jpg" alt></p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><a id="more"></a><h5 id="内存溢出的原因是什么？"><a href="#内存溢出的原因是什么？" class="headerlink" title="内存溢出的原因是什么？"></a>内存溢出的原因是什么？</h5><p>内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。如果出现这种现象可行代码排查：</p><ul><li><p>是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0; //public static String str;</p></li><li><p>是否 应用 中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）</p></li><li><p>是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）</p></li><li><p>检查 应用 中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。</p></li><li><p>检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。</p></li><li><p>检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行”+”就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如String s1 = &quot;My name&quot;;</span><br><span class="line"></span><br><span class="line">String s2 = &quot;is&quot;;</span><br><span class="line"></span><br><span class="line">String s3 = &quot;xuwei&quot;;</span><br><span class="line"></span><br><span class="line">String str = s1 + s2 + s3 +.........;这是会容易造成内存溢出的</span><br><span class="line"></span><br><span class="line">但是String str =  &quot;My name&quot; + &quot; is &quot; + &quot; xuwei&quot; + &quot; nice &quot; + &quot; to &quot; + &quot; meet you&quot;; //但是这种就不会造成内存溢出。因为这是”字面量字符串“，在运行&quot;+&quot;时就会在编译期间运行好。不会按照JVM来执行的。</span><br><span class="line"></span><br><span class="line">在使用String,StringBuffer,StringBuilder时，如果是字面量字符串进行&quot;+&quot;时，应选用String性能更好；如果是String类进行&quot;+&quot;时，在不考虑线程安全时，应选用StringBuilder性能更好。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHeap</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;  <span class="comment">//死循环一直创建对象，堆溢出</span></span><br><span class="line">              ArrayList list = <span class="keyword">new</span> ArrayList (<span class="number">2000</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;  <span class="comment">//无出口的递归调用，栈溢出</span></span><br><span class="line">        num++;  </span><br><span class="line">        <span class="keyword">this</span>.testStack();  </span><br><span class="line">     &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Test  t  = <span class="keyword">new</span> Test ();  </span><br><span class="line">        t.testHeap();  </span><br><span class="line">        t.testStack();     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈溢出的原因"><a href="#栈溢出的原因" class="headerlink" title="栈溢出的原因"></a>栈溢出的原因</h4><ul><li><p>是否有递归调用</p></li><li><p>是否有大量循环或死循环</p></li><li><p>全局变量是否过多</p></li><li><p>数组、List、map数据是否过大</p></li><li><p>使用DDMS工具进行查找大概出现栈溢出的位置</p></li></ul><h4 id="JVM系列之实战内存溢出异常"><a href="#JVM系列之实战内存溢出异常" class="headerlink" title="JVM系列之实战内存溢出异常"></a>JVM系列之实战内存溢出异常</h4><h5 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h5><p>关于对象的创建，第一反应是new关键字，那么本文就主要讲解new关键字创建对象的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu =new Student(&quot;张三&quot;，&quot;18&quot;);</span><br></pre></td></tr></table></figure></p><p>就拿上面这句代码来说，虚拟机首先会去检查Student这个类有没有被加载，如果没有，首先去加载这个类到方法区，然后根据加载的Class类对象创建stu实例对象，需要注意的是，stu对象所需的内存大小在Student类加载完成后便可完全确定。内存分配完成后，虚拟机需要将分配到的内存空间的实例数据部分初始化为零值,这也就是为什么我们在编写Java代码时创建一个变量不需要初始化。紧接着，虚拟机会对对象的对象头进行必要的设置，如这个对象属于哪个类，如何找到类的元数据(Class对象),对象的锁信息，GC分代年龄等。设置完对象头信息后，调用类的构造函数。<br>其实讲实话，虚拟机创建对象的过程远不止这么简单，我这里只是把大致的脉络讲解了一下，方便大家理解。</p><h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>刚刚提到的实例数据，对象头，有些小伙伴也许有点陌生，这一小节就详细讲解一下对象的内存布局,对象创建完成后大致可以分为以下几个部分:</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充</li></ul><p><strong><em>对象头</em></strong> : 对象头中包含了对象运行时一些必要的信息，如GC分代信息，锁信息，哈希码，指向Class类元信息的指针等，其中对Javaer比较有用的是锁信息与指向Class对象的指针，关于锁信息，后期有机会讲解并发编程JUC时再扩展，关于指向Class对象的指针其实很好理解。比如上面那个Student的例子，当我们拿到stu对象时，调用Class stuClass=stu.getClass();的时候，其实就是根据这个指针去拿到了stu对象所属的Student类在方法区存放的Class类对象。虽然说的有点拗口，但这句话我反复琢磨了好几遍，应该是说清楚了。^_^</p><p><strong><em>实例数据</em></strong> :实例数据部分是对象真正存储的有效信息，就是程序代码中所定义的各种类型的字段内容。</p><p><strong><em>对齐填充</em></strong> :虚拟机规范要求对象大小必须是8字节的整数倍。对齐填充其实就是来补全对象大小的。</p><h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>谈到对象的访问，还拿上面学生的例子来说，当我们拿到stu对象时，直接调用stu.getName();时，其实就完成了对对象的访问。但这里要累赘说一下的是，stu虽然通常被认为是一个对象，其实准确来说是不准确的，stu只是一个变量，变量里存储的是指向对象的指针，(如果干过C或者C++的小伙伴应该比较清楚指针这个概念)，当我们调用stu.getName()时，虚拟机会根据指针找到堆里面的对象然后拿到实例数据name.需要注意的是，当我们调用stu.getClass()时，虚拟机会首先根据stu指针定位到堆里面的对象，然后根据对象头里面存储的指向Class类元信息的指针再次到方法区拿到Class对象，进行了两次指针寻找。具体讲解图如下:<br><img src="http://47.103.200.134/image/b15.jpg" alt></p><h4 id="实战内存异常"><a href="#实战内存异常" class="headerlink" title="实战内存异常"></a>实战内存异常</h4><p>内存异常是我们工作当中经常会遇到问题，但如果仅仅会通过加大内存参数来解决问题显然是不够的，应该通过一定的手段定位问题，到底是因为参数问题，还是程序问题(无限创建，内存泄露)。定位问题后才能采取合适的解决方案，而不是一内存溢出就查找相关参数加大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概念</span><br><span class="line">- 内存泄露:代码中的某个对象本应该被虚拟机回收，但因为拥有GCRoot引用而没有被回收。关于GCRoot概念，下一篇文章讲解。</span><br><span class="line">- 内存溢出: 虚拟机由于堆中拥有太多不可回收对象没有回收，导致无法继续创建新对象。</span><br></pre></td></tr></table></figure><p>在分析问题之前先给大家讲一讲排查内存溢出问题的方法，内存溢出时JVM虚拟机会退出，那么我们怎么知道JVM运行时的各种信息呢，Dump机制会帮助我们，可以通过加上VM参数-XX:+HeapDumpOnOutOfMemoryError让虚拟机在出现内存溢出异常时生成dump文件，然后通过外部工具(作者使用的是VisualVM)来具体分析异常的原因。</p><p>下面从以下几个方面来配合代码实战演示内存溢出及如何定位:</p><ul><li>Java堆内存异常</li><li>Java栈内存异常</li><li>方法区内存异常</li></ul><h5 id="Java堆内存异常"><a href="#Java堆内存异常" class="headerlink" title="Java堆内存异常"></a>Java堆内存异常</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** VM Args: //这两个参数保证了堆中的可分配内存固定为20M -Xms20m -Xmx20m //文件生成的位置，作则生成在桌面的一个目录 -XX:+HeapDumpOnOutOfMemoryError //文件生成的位置，作则生成在桌面的一个目录 //文件生成的位置，作则生成在桌面的一个目录 -XX:HeapDumpPath=/Users/zdy/Desktop/dump/ */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    //创建一个内部类用于创建对象使用</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        //无限创建对象，在堆中</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run起来代码后爆出异常如下:</p><p><strong><em>java.lang.OutOfMemoryError: Java heap space</em></strong><br>Dumping heap to /Users/zdy/Desktop/dump/java_pid1099.hprof …</p><p>可以看到生成了dump文件到指定目录。并且爆出了OutOfMemoryError，还告诉了你是哪一片区域出的问题:heap space</p><p>打开VisualVM工具导入对应的heapDump文件(如何使用请读者自行查阅相关资料)，相应的说明见图:<br><img src="http://47.103.200.134/image/b16.png" alt><br>“类标签”</p><p>切换到”实例数”标签页<br><img src="http://47.103.200.134/image/b17.png" alt><br>“实例数标签”</p><p>分析dump文件后，我们可以知道，OOMObject这个类创建了810326个实例。所以它能不溢出吗？接下来就在代码里找这个类在哪new的。排查问题。(我们的样例代码就不用排查了，While循环太凶猛了)</p><h5 id="Java栈内存异常"><a href="#Java栈内存异常" class="headerlink" title="Java栈内存异常"></a>Java栈内存异常</h5><p>老实说，在栈中出现异常(StackOverFlowError)的概率小到和去苹果专卖店买手机，买回来后发现是Android系统的概率是一样的。因为作者确实没有在生产环境中遇到过，除了自己作死写样例代码测试。先说一下异常出现的情况，前面讲到过，方法调用的过程就是方法帧进虚拟机栈和出虚拟机栈的过程，那么有两种情况可以导致StackOverFlowError,当一个方法帧(比如需要2M内存)进入到虚拟机栈(比如还剩下1M内存)的时候，就会报出StackOverFlow.这里先说一个概念，栈深度:指目前虚拟机栈中没有出栈的方法帧。虚拟机栈容量通过参数-Xss来控制,下面通过一段代码，把栈容量人为的调小一点，然后通过递归调用触发异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * VM Args： //设置栈容量为160K，默认1M -Xss160k */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        <span class="comment">//递归调用，触发异常</span></span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:<br><strong><em>stack length:751</em></strong><br><strong><em>Exception in thread “main” java.lang.StackOverflowError</em></strong></p><p>可以看到，递归调用了751次，栈容量不够用了。<br>默认的栈容量在正常的方法调用时，栈深度可以达到1000-2000深度，所以，一般的递归是可以承受的住的。如果你的代码出现了StackOverflowError，首先检查代码，而不是改参数。</p><p>这里顺带提一下，很多人在做多线程开发时，当创建很多线程时，容易出现OOM(OutOfMemoryError),这时可以通过具体情况，减少最大堆容量，或者栈容量来解决问题，这是为什么呢。请看下面的公式:</p><p><strong><em>线程数 乘以 (最大栈容量)+最大堆值+其他内存(忽略不计或者一般不改动)=机器最大内存</em></strong></p><p>当线程数比较多时，且无法通过业务上削减线程数，那么再不换机器的情况下，你只能把最大栈容量设置小一点，或者把最大堆值设置小一点。</p><h5 id="方法区内存异常"><a href="#方法区内存异常" class="headerlink" title="方法区内存异常"></a>方法区内存异常</h5><p>写到这里时，作者本来想写一个无限创建动态代理对象的例子来演示方法区溢出，避开谈论JDK7与JDK8的内存区域变更的过渡，但细想一想，还是把这一块从始致终的说清楚。在上一篇文章中JVM系列之Java内存结构详解讲到方法区时提到，JDK7环境下方法区包括了(运行时常量池),其实这么说是不准确的。因为从JDK7开始，HotSpot团队就想到开始去”永久代”,大家首先明确一个概念，方法区和”永久代”(PermGen space)是两个概念，方法区是JVM虚拟机规范，任何虚拟机实现(J9等)都不能少这个区间，而”永久代”只是HotSpot对方法区的一个实现。为了把知识点列清楚，我还是才用列表的形式:</p><ul><li>JDK7之前(包括JDK7)拥有”永久代”(PermGen space),用来实现方法区。但在JDK7中已经逐渐在实现中把永久代中把很多东西移了出来，比如:符号引用(Symbols)转移到了native heap,运行时常量池(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap.<br>所以这就是为什么我说上一篇文章中说方法区中包含运行时常量池是不正确的，因为已经移动到了java heap;</li><li>在JDK7之前(包括7)可以通过-XX:PermSize -XX:MaxPermSize来控制永久代的大小.</li><li>JDK8正式去除”永久代”,换成Metaspace(元空间)作为JVM虚拟机规范中方法区的实现。</li><li>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但仍可以通过参数控制:-XX:MetaspaceSize与-XX:MaxMetaspaceSize来控制大小。</li></ul><p>下面作者还是通过一段代码，来不停的创建Class对象，在JDK8中可以看到metaSpace内存溢出:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 作者准备在JDK8下测试方法区，所以设置了Metaspace的大小为固定的8M -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//无限创建动态代理，生成Class对象</span></span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK8的环境下将报出异常:<br><strong><em>Exception in thread “main” java.lang.OutOfMemoryError: Metaspace</em></strong><br>这是因为在调用CGLib的创建代理时会生成动态代理类，即Class对象到Metaspace,所以While一下就出异常了。<br><strong><em>提醒一下:虽然我们日常叫”堆Dump”,但是dump技术不仅仅是对于”堆”区域才有效，而是针对OOM的，也就是说不管什么区域，凡是能够报出OOM错误的，都可以使用dump技术生成dump文件来分析。</em></strong></p><p>在经常动态生成大量Class的应用中，需要特别注意类的回收状况，这类场景除了例子中的CGLib技术，常见的还有，大量JSP，反射，OSGI等。需要特别注意，当出现此类异常，应该知道是哪里出了问题，然后看是调整参数，还是在代码层面优化。</p><h5 id="附加-直接内存异常"><a href="#附加-直接内存异常" class="headerlink" title="附加-直接内存异常"></a>附加-直接内存异常</h5><p>直接内存异常非常少见，而且机制很特殊，因为直接内存不是直接向操作系统分配内存，而且通过计算得到的内存不够而手动抛出异常，所以当你发现你的dump文件很小，而且没有明显异常，只是告诉你OOM，你就可以考虑下你代码里面是不是直接或者间接使用了NIO而导致直接内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：https://my.oschina.net/u/2401092/blog/1621850</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内存溢出-amp-amp-栈溢出&quot;&gt;&lt;a href=&quot;#内存溢出-amp-amp-栈溢出&quot; class=&quot;headerlink&quot; title=&quot;内存溢出&amp;amp;&amp;amp;栈溢出&quot;&gt;&lt;/a&gt;内存溢出&amp;amp;&amp;amp;栈溢出&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p5.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;内存溢出&quot;&gt;&lt;a href=&quot;#内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存溢出&quot;&gt;&lt;/a&gt;内存溢出&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程安全性、安全发布对象</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/并发编程之线程安全性、安全发布对象/</id>
    <published>2019-05-23T15:04:38.000Z</published>
    <updated>2019-06-11T04:29:04.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><img src="http://47.103.200.134/image/p6.jpg" alt><br>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。<br><a id="more"></a><br>线程安全性主要体现：</p><ol><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般是杂乱无序</li></ol><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><h5 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h5><p>位于java.util.concurrent.atomic<br>AtomicXXX : CAS、Unsafe.compareAndSwapXXX<br>  CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p><h6 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class CountExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line">    //从int类型换成了AtomicInteger</span><br><span class="line">    public static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        //调用了AtomicInteger方法</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        // count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全？源码分析<br>AtomicInteger.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line">// setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe(); //通过反射获得</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">       (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">   &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">        //this 代表当前AtomicInteger对象</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Unsafe.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//本地方法，java底层方法</span><br><span class="line">/**</span><br><span class="line"> * @param var1 对象</span><br><span class="line"> * @param var2 偏移量</span><br><span class="line"> * @param var3 期望值</span><br><span class="line"> * @param var5 修改值</span><br><span class="line"> */</span><br><span class="line"> public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param var1 当前对象</span><br><span class="line"> * @param var2 当前值</span><br><span class="line"> * @param var3 增量</span><br><span class="line"> */</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">        int var5; //底层值</span><br><span class="line">        do &#123;</span><br><span class="line">            var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        // CAS核心</span><br><span class="line">        //当前值与底层值相同，则更新成var5 + var4</span><br><span class="line">        //不一样则不停的循环，直到值相同</span><br><span class="line">        return var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AtomicInLong 与 LongAdder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static AtomicLong count = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        // count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample3 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static LongAdder count = new LongAdder();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        count.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInLong 与 LongAdder 比较<br>就像我们所知道的那样,AtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。如果竞争不激烈，修改成功几率很高，否则失败概率很高，在失败几率很高的情况下，这些原子操作就会进行多次的循环操作尝试，因此性能会受到影响。</p><p>对于普通类型的Long和Doubble变量，JVM允许将64位的读操作或写操作拆成两个三十二位的操作。</p><p>LongAdder的核心是将热点数据分离，比如说它可以将AtomicLong内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法，映射到其中一个数字进行计数，最终的计数结果则会这个数据的求和累加，其中热点数据value会被分离成多个cell，每个cell独自维护内部的值，当前对象实际值为所有cell累计合成，这样的话，热点就进行了有效的分离，并提高了并行度。</p><p>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</p><p>​缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。</p><p>​实际使用中，在处理高并发时，可以优先使用LongAdder，而不是继续使用AtomicLong，当然，在线程竞争很低的情况下，使用AtomicLong更简单更实际一些，并且效率会高些。其他情况下，比如序列号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择，而不是LongAdder</p><h6 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The AtomicReference class provides reference objects that may be read and written atomically, so when multiple threads try to reach them at the same time, only one will be able to do so</span><br></pre></td></tr></table></figure><h5 id="原子性引用"><a href="#原子性引用" class="headerlink" title="原子性引用"></a>原子性引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample4 &#123;</span><br><span class="line"></span><br><span class="line">    private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        count.compareAndSet(0, 2); // 2</span><br><span class="line">        count.compareAndSet(0, 1); // no</span><br><span class="line">        count.compareAndSet(1, 3); // no</span><br><span class="line">        count.compareAndSet(2, 4); // 4</span><br><span class="line">        count.compareAndSet(3, 5); // no</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例比较简单，我有个疑问？假如我们引用的是一个自定义的对象，并且对象里面有属性值，然后，修改对象中的属性值也是原子性的吗？还是只是对对象的引用是原子性操作。<br>带着上面的疑问，进行源码分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -1848883965231344442L;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile V value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new AtomicReference with the given initial value.</span><br><span class="line">     *</span><br><span class="line">     * @param initialValue the initial value</span><br><span class="line">     */</span><br><span class="line">    public AtomicReference(V initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new AtomicReference with null initial value.</span><br><span class="line">     */</span><br><span class="line">    public AtomicReference() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不需要安全防护</span><br><span class="line">     */</span><br><span class="line">    public final V get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设值值不需要进行对象安全防护</span><br><span class="line">     */</span><br><span class="line">    public final void set(V newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 很明显调用的是csa操作</span><br><span class="line">     * 比较对象是否相同，进行设值</span><br><span class="line">     * 设值成功返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置新的值并且返回旧的值</span><br><span class="line">     * 原子操作</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public final V getAndSet(V newValue) &#123;</span><br><span class="line">        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过源码分析，可以得出</p><ul><li>AtomicReference 所提供的某些方法可以进行原子性操作，如compareAndSet、getAndSet，这仅仅是对引用进行原子性操作</li><li>AtomicReference  不能保证对象中若存在属性值修改是线程安全的，如假设引用对象是person，修改person中name和age，多个线程同时从引用中获得对象，并进行修改，会出现线程不安全情况。下面我们通过代码来验证一下这条结论。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 1000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 500;</span><br><span class="line"></span><br><span class="line">    public static Person person = new Person(0,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;Person&gt; personAtomicReference = new AtomicReference(person);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            final int result = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    modify(result);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;name:&#123;&#125;,age:&#123;&#125;&quot;,personAtomicReference.get().getName(), personAtomicReference.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果线程安全的话，age的值和name的值是一致的</span><br><span class="line">    //如果线程不安全的话，age的值和name是不一样的。</span><br><span class="line">    private static void modify(int i) &#123;</span><br><span class="line">        personAtomicReference.get().setAge(personAtomicReference.get().getAge() + i);</span><br><span class="line">        personAtomicReference.get().setName(personAtomicReference.get().getName() + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在低并发的情况下，输出的结果是正确的，但是在高并发的情况下结果差距就很大了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:09:52.473 [main] INFO com.mmall.concurrency.example.atomic.AtomicReferenceTest - name:496592,age:496922</span><br></pre></td></tr></table></figure></p><h6 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h6><p>atomic包中提供AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater，原子性的更新某一个类实例的指定的某一个字段</p><ul><li>AtomicIntegerFieldUpdater<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AtomicIntegerFieldUpdater 原子性的更新某一个类的实例的指定的某一个字段</span></span><br><span class="line">    <span class="comment">//并且该字段由volatile进行修饰同时不能被static修饰</span></span><br><span class="line">    <span class="comment">//有些网上说而且不能被private修饰？下文将进行验证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:48:27.815 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 120</span><br><span class="line">18:48:27.825 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120</span><br></pre></td></tr></table></figure></p><p>源码分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tclass 持有某字段的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName 字段名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String fieldName)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子性设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get(obj);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, newValue));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterImpl</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; tclass;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line">                                      <span class="keyword">final</span> String fieldName,</span><br><span class="line">                                      <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line">            <span class="keyword">final</span> Field field;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">                            <span class="comment">//字段不存在会抛异常</span></span><br><span class="line">                            <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                 <span class="comment">//检查访问级别</span></span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">                  sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">            <span class="comment">//必须是int</span></span><br><span class="line">            <span class="keyword">if</span> (fieldt != <span class="keyword">int</span>.class)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be integer type"</span>);</span><br><span class="line">            <span class="comment">//必须用volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">            <span class="comment">//用Unsafe里的那一坨方法去原子更新</span></span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码分析中，可以看出没有要求不能被private修饰</p><h6 id="AtomicStampReference"><a href="#AtomicStampReference" class="headerlink" title="AtomicStampReference"></a>AtomicStampReference</h6><p> 此类是要核心解决CAS的ABA问题<br> ​   ABA问题：指CAS操作的时候，线程将某个变量值由A修改为B，但是又改回了A，其他线程发现A并未改变，于是CAS将进行值交换操作，实际上该值已经被改变过，这与CAS的核心思想是不符合的</p><p> ​   解决思路：每次变量更新的时候，把变量的版本号进行更新，如果某变量被某个线程修改过，那么版本号一定会递增更新，从而解决ABA问题</p><p> ​   J.U.C 提供了两个类解决ABA问题，一个是AtomicStampReference ，另一个是 AtomicMarkableReference</p><h6 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h6><p> AtomicLong是作用是对长整形进行原子操作。而AtomicLongArray的作用则是对”长整形数组”进行原子操作,根据索引，对数据中的指定位置的数据进行院子性的更新</p><h6 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h6> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappened = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"isHappened:&#123;&#125;"</span>, isHappened.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 演示如何让一段代码中的某个逻辑在高并发场景下只执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原子性操作，保证从false 到 true 只会执行一次</span></span><br><span class="line">        <span class="keyword">if</span> (isHappened.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"execute"</span>); <span class="comment">//只会执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h6><p>JAVA中能保证同一时刻，只有一个线程来进行对其进行操作的，除了atomic包中所提供的类之外，还有jdk提供的锁，JAVA主要提供以下锁：</p><ol><li><p>synchronized : 关键字，并且依赖与JVM，作用对象的作用范围内都是同一时刻只能有一个线程对其操作的</p></li><li><p>Lock : 接口类，依赖特殊的CPU指定，使用代码实现，常用子类ReentrantLock</p></li></ol><h6 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h6><ul><li>修饰代码块：大括号括起来的代码，也称同步代码块，作用与调用的对象</li><li>修饰方法：整个方法，也称同步方法，作用与调用的对象</li><li>修饰静态方法：整个静态方法，作用于类的所有对象</li><li>修饰类：括号括起来的部分，作用与类的所有对象</li></ul><h6 id="同步代码块与同步方法演示与解析"><a href="#同步代码块与同步方法演示与解析" class="headerlink" title="同步代码块与同步方法演示与解析"></a>同步代码块与同步方法演示与解析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块 作用于调用的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法 同步方法 作用于调用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test2(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//example1.test2(1)</span></span><br><span class="line">            example2.test2(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若线程池中开启两个线程：</p><p>使用同步方法进行验证：</p><p>​ 若两个线程中都使用同一个对象进行操作，那么他们是同步的,输出的结果都是先执行test2-1 0-9的输出后执行test2-2 0-9的输出或先执行test2-2 0-9的输出后执行test2-1 0-9的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(1);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(2)</span><br><span class="line">    //example2.test2(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若两个线程中不使用同一个对象进行操作，那么他们输出即为交叉执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(1);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    //example1.test2(2)</span><br><span class="line">    example2.test2(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意：如果某个类为父类，并且存在同步方法，子类在继承这个类后，如果子类调用该父类的同步方法后，该方法是没有synchronized关键字的，原因是synchronized不属于方法声明的一部分</p><p>修饰静态方法与修饰类演示与解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//作用于类的所有对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample2.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test1(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//example1.test2(1);</span></span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example2.test1(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//example2.test2(2);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面类的执行结果，同一个类的不同对象执行同步修饰的方法，执行的顺序是同步的</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ul><li>synchronized ：不可中断锁，适合竞争不激烈，可读性较好</li><li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li><li>Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值</li></ul><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>一个线程对主内存的修改可以及时的被其他线程观察到。<br>导致共享变量在线程间不可见的原因：</p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>对于可见性，JVM提供了 synchronized 和 volatile</p><h6 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h6><p> JMM关于synchronized的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li><p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）</p><h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>通过加入内存屏障和禁止重排序优化来实现</p></li><li><p>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存中<br><img src="http://47.103.200.134/image/b13.png" alt></p></li><li><p>对volatile变量读操作是，会在读操作前加入一条load屏障指令，从主内存中读取共享变量<br><img src="http://47.103.200.134/image/b14.png" alt></p><p>通过上面两点，任何时候，不同的线程总能看到该变量的最新值。所有的指令操作都是CPU级别的</p><h6 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果是线程不安全的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过例子可以得知，即使通过volatile修饰变量，但依然无法保证线程安全</p><p>原因分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void add() &#123;</span><br><span class="line">    count++; //分3步</span><br><span class="line">    //1.取出当前count值</span><br><span class="line">    //2.count + 1</span><br><span class="line">    //3.count 重新写回主存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设同时有两个线程进行操作，两个线程同时执行到第一步（从内存中读取最新值）得到一样的最新的结果，然后进入第二步（+1操作）并进行第三步（从新写回主存）。尽管第一步获取的值是一样的，但是同时将+1后的操作写回主存，这样就会丢掉某个+1的操作，这样就会出现线程不安全问题<br>结论：</p><ul><li>volatile进行加操作线程不安全的，不适合计数场景</li><li>volatile关键字不具有原子性</li></ul><p>使用场景<br>  使用volatile必须具备两个条件</p><ul><li>对变量的写操作，不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式子中</li></ul><p>因此volatile适合作为状态的标记量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">context = loadContext();</span><br><span class="line">inited = true;</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>JAVA内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p><p>volatile、synchronized、Lock：通过 volatile、synchronized、Lock 保证一定的有序性。显然，synchronized、Lock 保证每一个时刻只有一个线程可以执行被同步的代码，相当于让线程顺序执行同步代码，从而保证有序性。另外，JMM具备一些先天的有序性，即不需要额外的手段，就能保证有序性，即 Happens-before 原则，如果两个操作的执行次序，没有办法通过 Happens-before   原则推到出来，虚拟机进行随意的重排序，那么就不能保证有序行。</p><h6 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h6><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li></ul><p>(个人理解：一段程序代码的执行，在单个线程中看起来是有序的，程序看起来的执行是按照代码的顺序执行的，因为虚拟机可能会对指令进行重排序，虽然进行了重排序，但是最终结果是与程序顺序执行的结果是一致的，只会对不存在数据依赖的指令进行重排序，因此在单个线程中是有序执行的。这条规则是保证程序在单线程中执行结果的正确性，但无法保证多线程执行结果的正确性)</p><ul><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p></li></ul><h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><p>安全发布对象的四种方法：</p><ol><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>  Spring 框架中，Spring管理的类都是单例模式。如何保证一个实例只被初始化一次，且线程安全？通过不同单例的写法，具体描述安全发布对象的四种方法：</p><h5 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可能这里会存在很多的操作</span></span><br><span class="line">        <span class="comment">//如资源加载、运算等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="comment">// 单线毫无问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程环境下存在线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：1.若构造方法中存在过多的处理、会导加载缓慢，从而引起性能问题</span></span><br><span class="line"><span class="comment"> *       2.只进行加载，并无实际调用，导致资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双重检测机制"><a href="#双重检测机制" class="headerlink" title="双重检测机制"></a>双重检测机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样的双重检测机制是线程不安全的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程环境下</span></span><br><span class="line">    <span class="comment">// JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设存在线程A、B同时进入双重检测机制</span></span><br><span class="line">    <span class="comment">//当线程A执行到 instance = new SingletonExample4(); // A - 执行到指令的第三步进行内存分配，但是未初始化对象</span></span><br><span class="line">    <span class="comment">//B执行到 if (instance == null) &#123; // 双重检测机制     //b发现instance不为空，直接返回对象，实上对象初始化并未开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 静态域与静态代码块是顺序执行的，若将1 2 处位置进行交换则会出现空指针异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最安全的枚举模式"><a href="#最安全的枚举模式" class="headerlink" title="最安全的枚举模式"></a>最安全的枚举模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h3><p>创建后状态不能被修改的对象叫作不可变对象。不可变对象天生就是线程安全的。它们的常量（变量）是在构造函数中创建的，既然它们的状态无法被修改，那么这些常量永远不会被改变——不可变对象永远是线程安全的。<br>不可变对象需要满足的条件</p><ul><li>对象创建以后其状态就不能修改</li><li>对象所有域都是final类型</li><li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li></ul><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final关键字：类、方法、变量</p><ul><li>修饰类：不能被继承，final类中的成员属性可以根据需要设置为final，但final类中所有的成员方法都被隐式指定为final方法。一般不建议将类设置为final类型。可以参考String类。</li><li>修饰方法：1）锁定方法不被继承类修改；2）效率</li><li>修饰变量：1）基本数据类型变量，初始化后便不能进行修改；2）引用类型变量，初始化之后不能再指向别的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="comment">//引用类型不允许引用指向改变，但是对象值还是可以进行修改的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 2;              //编译时报错</span></span><br><span class="line"><span class="comment">//        b = "3";            //编译时报错</span></span><br><span class="line"><span class="comment">//        map = Maps.newHashMap();   //编译时报错</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);       <span class="comment">//容易引发线程安全问题</span></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以修饰参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p>java提供Collections工具类，在类中提供了多种不允许修改的方法</p><p>​ Collections.unmodifiableXXX：Collection、List、Set、Map…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(1, 2);</span><br><span class="line">        map.put(3, 4);</span><br><span class="line">        map.put(5, 6);</span><br><span class="line">        //处理过后的map是不可以再进行修改的</span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //允许操作，但是操作会报错，扔出异常</span><br><span class="line">        map.put(1, 3);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p>​ 谷歌的Guava提供类似Java中的Collections</p><p>​ ImmutableXXX：Collection、List、Set、Map…</p><p><strong><em>pom.xml</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);</span><br><span class="line">    </span><br><span class="line">    private final static List&lt;Integer&gt; lists = ImmutableList.of(1, 2, 3);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(1, 2).put(3, 4).put(5, 6).build();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(map2.get(3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：https://www.jianshu.com/p/895950290179</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p6.jpg&quot; alt&gt;&lt;br&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CPU缓存一致性协议MESI</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/CPU缓存一致性协议MESI/</id>
    <published>2019-05-23T03:40:52.000Z</published>
    <updated>2019-06-11T04:27:38.530Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p3.jpg" alt="输入图片说明"></p><h3 id="CPU高速缓存（Cache-Memory）"><a href="#CPU高速缓存（Cache-Memory）" class="headerlink" title="CPU高速缓存（Cache Memory）"></a>CPU高速缓存（Cache Memory）</h3><h4 id="CPU为何要有高速缓存"><a href="#CPU为何要有高速缓存" class="headerlink" title="CPU为何要有高速缓存"></a>CPU为何要有高速缓存</h4><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p><a id="more"></a><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</span><br></pre></td></tr></table></figure><p>比如循环、递归、方法的反复调用等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</span><br></pre></td></tr></table></figure><p>比如顺序执行的代码、连续创建的两个对象、数组等。</p><h4 id="带有高速缓存的CPU执行计算的流程"><a href="#带有高速缓存的CPU执行计算的流程" class="headerlink" title="带有高速缓存的CPU执行计算的流程"></a>带有高速缓存的CPU执行计算的流程</h4><ol><li><p>程序以及数据被加载到主内存</p></li><li><p>指令和数据被加载到CPU的高速缓存</p></li><li><p>CPU执行指令，把结果写到高速缓存</p></li><li><p>高速缓存中的数据写回主内存</p></li></ol><p><img src="http://47.103.200.134/image/b5.png" alt></p><h4 id="目前流行的多级缓存结构"><a href="#目前流行的多级缓存结构" class="headerlink" title="目前流行的多级缓存结构"></a>目前流行的多级缓存结构</h4><p>由于CPU的运算速度超越了1级缓存的数据I\O能力，CPU厂商又引入了多级的缓存结构。</p><p>多级缓存结构<br><img src="http://47.103.200.134/image/b6.png" alt></p><h3 id="多核CPU多级缓存一致性协议MESI"><a href="#多核CPU多级缓存一致性协议MESI" class="headerlink" title="多核CPU多级缓存一致性协议MESI"></a>多核CPU多级缓存一致性协议MESI</h3><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。</p><h4 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a>MESI协议缓存状态</h4><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存行（Cache line）:缓存存储数据的单元。</span><br></pre></td></tr></table></figure><p><img src="http://47.103.200.134/image/b1.png" alt="输入图片说明"></p><p>注意：<br> <strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。</strong><br>如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p><p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p><h4 id="MESI状态转换"><a href="#MESI状态转换" class="headerlink" title="MESI状态转换"></a>MESI状态转换</h4><p><img src="http://47.103.200.134/image/b7.png" alt="输入图片说明"></p><p>理解该图的前置说明：<br>1.触发事件</p><table><br><thead><br><tr class="header"><br><th style="text-align: left;">触发事件</th><br><th style="text-align: left;">描述</th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: left;">本地读取（Local read）</td><br><td style="text-align: left;">本地cache读取本地cache数据</td><br></tr><br><tr class="even"><br><td style="text-align: left;">本地写入（Local write）</td><br><td style="text-align: left;">本地cache写入本地cache数据</td><br></tr><br><tr class="odd"><br><td style="text-align: left;">远端读取（Remote read）</td><br><td style="text-align: left;">其他cache读取本地cache数据</td><br></tr><br><tr class="even"><br><td style="text-align: left;">远端写入（Remote write）</td><br><td style="text-align: left;">其他cache写入本地cache数据</td><br></tr><br></tbody><br></table><p>2.cache分类：<br>前提：所有的cache共同缓存了主内存中的某一条数据。</p><p>本地cache:指当前cpu的cache。<br>触发cache:触发读写事件的cache。<br>其他cache:指既除了以上两种之外的cache。<br>注意：本地的事件触发 本地cache和触发cache为相同。</p><p>上图的切换解释：</p><table><br><thead><br><tr class="header"><br><th style="text-align: center;">状态</th><br><th style="text-align: center;">触发本地读取</th><br><th style="text-align: center;">触发本地写入</th><br><th style="text-align: center;">触发远端读取</th><br><th style="text-align: center;">触发远端写入</th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: center;"><strong>M状态（修改）</strong></td><br><td style="text-align: center;">本地cache:M <br>触发cache:M<br>其他cache:I</td><br><td style="text-align: center;">本地cache:M <br>触发cache:M<br>其他cache:I</td><br><td style="text-align: center;">本地cache:M→E→S<br>触发cache:I→S<br>其他cache:I→S<br>同步主内存后修改为E独享,同步触发、其他cache后本地、触发、其他cache修改为S共享</td><br><td style="text-align: center;">本地cache:M→E→S→I<br>触发cache:I→S→E→M<br>其他cache:I→S→I<br>同步和读取一样,同步完成后触发cache改为M，本地、其他cache改为I</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>E状态（独享）</strong></td><br><td style="text-align: center;">本地cache:E<br>触发cache:E<br>其他cache:I</td><br><td style="text-align: center;">本地cache:E→M<br>触发cache:E→M<br>其他cache:I<br>本地cache变更为M,其他cache状态应当是I（无效）</td><br><td style="text-align: center;">本地cache:E→S<br>触发cache:I→S<br>其他cache:I→S<br>当其他cache要读取该数据时，其他、触发、本地cache都被设置为S(共享)</td><br><td style="text-align: center;">本地cache:E→S→I<br>触发cache:I→S→E→M<br>其他cache:I→S→I<br>当触发cache修改本地cache独享数据时时，将本地、触发、其他cache修改为S共享.然后触发cache修改为独享，其他、本地cache修改为I（无效），触发cache再修改为M</td><br></tr><br><tr class="odd"><br><td style="text-align: center;"><strong>S状态(共享)</strong></td><br><td style="text-align: center;">本地cache:S<br>触发cache:S<br>其他cache:S</td><br><td style="text-align: center;">本地cache:S→E→M<br>触发cache:S→E→M<br>其他cache:S→I <br>当本地cache修改时，将本地cache修改为E,其他cache修改为I,然后再将本地cache为M状态</td><br><td style="text-align: center;">本地cache:S<br>触发cache:S<br>其他cache:S</td><br><td style="text-align: center;">本地cache:S→I<br>触发cache：S→E→M<br>其他cache:S→I<br>当触发cache要修改本地共享数据时，触发cache修改为E（独享）,本地、其他cache修改为I（无效）,触发cache再次修改为M(修改)</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>I状态（无效）</strong></td><br><td style="text-align: center;">本地cache:I→S或者I→E<br>触发cache:I→S或者I →E<br>其他cache:E、M、I→S、I<br>本地、触发cache将从I无效修改为S共享或者E独享，其他cache将从E、M、I 变为S或者I</td><br><td style="text-align: center;">本地cache:I→S→E→M<br>触发cache:I→S→E→M<br>其他cache:M、E、S→S→I<br></td><br><td style="text-align: center;">既然是本cache是I，其他cache操作与它无关</td><br><td style="text-align: center;">既然是本cache是I，其他cache操作与它无关</td><br></tr><br></tbody><br></table><p>下图示意了，当一个cache line的调整的状态的时候，另外一个cache line 需要调整的状态。</p><table><br><thead><br><tr class="header"><br><th style="text-align: center;"></th><br><th style="text-align: center;">M</th><br><th style="text-align: center;">E</th><br><th style="text-align: center;">S</th><br><th style="text-align: center;"><strong>I</strong></th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: center;"><strong>M</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>E</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="odd"><br><td style="text-align: center;"><strong>S</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>I</strong></td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br></tr><br></tbody><br></table><p>举个栗子来说：</p><p>假设cache 1 中有一个变量x = 0的cache line 处于S状态(共享)。<br>那么其他拥有x变量的cache 2、cache 3等x的cache line调整为S状态（共享）或者调整为 I 状态（无效）。</p><h4 id="多核缓存协同操作"><a href="#多核缓存协同操作" class="headerlink" title="多核缓存协同操作"></a>多核缓存协同操作</h4><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0。</p><p><img src="http://47.103.200.134/image/b8.png" alt></p><h5 id="单核读取"><a href="#单核读取" class="headerlink" title="单核读取"></a>单核读取</h5><p>那么执行流程是：<br>CPU A发出了一条指令，从主内存中读取x。<br>从主内存通过bus读取到缓存中（远端读取Remote read）,这是该Cache line修改为E状态（独享）.</p><p><img src="http://47.103.200.134/image/b9.png" alt></p><h5 id="双核读取"><a href="#双核读取" class="headerlink" title="双核读取"></a>双核读取</h5><p>那么执行流程是：<br>CPU A发出了一条指令，从主内存中读取x。<br>CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态。<br>CPU B发出了一条指令，从主内存中读取x。<br>CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在chche a和cache b中都被设置为S状态(共享)。</p><p><img src="http://47.103.200.134/image/b10.png" alt></p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><p>那么执行流程是：<br>CPU A 计算完成后发指令需要修改x.<br>CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效)<br>CPU A 对x进行赋值。</p><p><img src="http://47.103.200.134/image/b11.png" alt></p><h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>那么执行流程是：</p><p>CPU B 发出了要读取x的指令。<br>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）<br>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。</p><p><img src="http://47.103.200.134/image/b12.png" alt="输入图片说明"></p><h3 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a>MESI优化和他们引入的问题</h3><p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p><h4 id="CPU切换状态阻塞解决-存储缓存（Store-Bufferes）"><a href="#CPU切换状态阻塞解决-存储缓存（Store-Bufferes）" class="headerlink" title="CPU切换状态阻塞解决-存储缓存（Store Bufferes）"></a>CPU切换状态阻塞解决-存储缓存（Store Bufferes）</h4><p>比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。</p><h5 id="Store-Bufferes"><a href="#Store-Bufferes" class="headerlink" title="Store Bufferes"></a>Store Bufferes</h5><p>为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。<br>这么做有两个风险</p><p>Store Bufferes的风险<br>第一、就是处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。<br>第二、保存什么时候会完成，这个并没有任何保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">value = 3；</span><br><span class="line"></span><br><span class="line">void exeToCPUA()&#123;</span><br><span class="line">  value = 10;</span><br><span class="line">  isFinsh = true;</span><br><span class="line">&#125;</span><br><span class="line">void exeToCPUB()&#123;</span><br><span class="line">  if(isFinsh)&#123;</span><br><span class="line">    //value一定等于10？！</span><br><span class="line">    assert value == 10;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试想一下开始执行时，CPU A保存着finished在E(独享)状态，而value并没有保存在它的缓存中。（例如，Invalid）。在这种情况下，value会比finished更迟地抛弃存储缓存。完全有可能CPU B读取finished的值为true，而value的值不等于10。<br> <strong>即isFinsh的赋值在value赋值之前。</strong> </p><p>这种在可识别的行为中发生的变化称为重排序（reordings）。注意，这不意味着你的指令的位置被恶意（或者好意）地更改。</p><p>它只是意味着其他的CPU会读到跟程序中写入的顺序不一样的结果。</p><p>顺便提一下NIO的设计和Store Bufferes的设计是非常相像的。</p><h4 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h4><p>执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。它们的约定如下：</p><ul><li>对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li><li>Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行。</li><li>处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。</li></ul><p>即便是这样处理器已然不知道什么时候优化是允许的，而什么时候并不允许。<br>干脆处理器将这个任务丢给了写代码的人。这就是内存屏障（Memory Barriers）。</p><p><code>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void executedOnCpu0() &#123;</span><br><span class="line">    value = 10;</span><br><span class="line">    //在更新数据之前必须将所有存储缓存（store buffer）中的指令执行完毕。</span><br><span class="line">    storeMemoryBarrier();</span><br><span class="line">    finished = true;</span><br><span class="line">&#125;</span><br><span class="line">void executedOnCpu1() &#123;</span><br><span class="line">    while(!finished);</span><br><span class="line">    //在读取之前将所有失效队列中关于该数据的指令执行完毕。</span><br><span class="line">    loadMemoryBarrier();</span><br><span class="line">    assert value == 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在确实安全了。完美无暇！</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>然而，对于程序员来说简直是一个灾难。不想和平台耦合我们要跨平台。Write One,Run Everywhere!<br>幸好java解决了这个问题，至于如何解决的请关注JMM(JavaMemoryMode)与物理内存相爱相杀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源： https://www.cnblogs.com/yanlong300/p/8986041.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p3.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;CPU高速缓存（Cache-Memory）&quot;&gt;&lt;a href=&quot;#CPU高速缓存（Cache-Memory）&quot; class=&quot;headerlink&quot; title=&quot;CPU高速缓存（Cache Memory）&quot;&gt;&lt;/a&gt;CPU高速缓存（Cache Memory）&lt;/h3&gt;&lt;h4 id=&quot;CPU为何要有高速缓存&quot;&gt;&lt;a href=&quot;#CPU为何要有高速缓存&quot; class=&quot;headerlink&quot; title=&quot;CPU为何要有高速缓存&quot;&gt;&lt;/a&gt;CPU为何要有高速缓存&lt;/h4&gt;&lt;p&gt;CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/内存屏障/</id>
    <published>2019-05-23T02:29:38.000Z</published>
    <updated>2019-06-11T04:29:18.191Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p2.jpg" alt="输入图片说明"></p><h4 id="为什么会有内存屏障"><a href="#为什么会有内存屏障" class="headerlink" title="为什么会有内存屏障"></a>为什么会有内存屏障</h4><ul><li>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。</li><li>用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。<a id="more"></a><h4 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h4></li><li>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。</li><li><p>内存屏障有两个作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阻止屏障两侧的指令重排序；</span><br><span class="line">强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</span><br></pre></td></tr></table></figure></li><li><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p></li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li></ul><h4 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h4><ul><li>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</li><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 <strong><em>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</em></strong></li></ul><h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><ul><li><p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是列表文本在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</span><br><span class="line">在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</span><br></pre></td></tr></table></figure></li><li><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p></li></ul><h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><ul><li><p>对于final域，编译器和CPU会遵循两个排序规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</span><br><span class="line">初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</span><br></pre></td></tr></table></figure></li><li><p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p></li><li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。</li><li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</li><li>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://www.jianshu.com/p/2ab5e3d7e510</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p2.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么会有内存屏障&quot;&gt;&lt;a href=&quot;#为什么会有内存屏障&quot; class=&quot;headerlink&quot; title=&quot;为什么会有内存屏障&quot;&gt;&lt;/a&gt;为什么会有内存屏障&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。&lt;/li&gt;
&lt;li&gt;用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>LongAdder解析</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/LongAdder%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/LongAdder解析/</id>
    <published>2019-05-23T00:14:41.000Z</published>
    <updated>2019-06-11T04:28:22.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LongAdder解析"><a href="#LongAdder解析" class="headerlink" title="LongAdder解析"></a>LongAdder解析</h3><p><img src="http://47.103.200.134/image/p1.jpg" alt="输入图片说明"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘要： 对`LongAdder`的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于`AtomicLong`来说，更加适合写多读少的并发情景。今天，我们就研究一下`LongAdder`的原理，探究一下它如此高效的原因。</span><br></pre></td></tr></table></figure><a id="more"></a><p>对LongAdder的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于AtomicLong来说，更加适合写多读少的并发情景。今天，我们就研究一下LongAdder的原理，探究一下它如此高效的原因。</p><h4 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java有很多并发控制机制，比如说以AQS为基础的锁或者以CAS为原理的自旋锁。不了解AQS的朋友可以阅读我之前的AQS源码解析文章。一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</span><br><span class="line"></span><br><span class="line"> 所以，如果你有一个Long类型的值会被多线程修改，那么使用CAS进行并发控制比较好，但是如果你是需要锁住一些资源，然后进行数据库操作，那么还是使用阻塞锁比较好。</span><br><span class="line"></span><br><span class="line"> 第一种情况下，我们一般都使用AtomicLong。AtomicLong是通过无限循环不停的采取CAS的方法去设置内部的value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。</span><br><span class="line"></span><br><span class="line"> 而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”。</span><br><span class="line"></span><br><span class="line"> 我们知道LongAdder的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</span><br></pre></td></tr></table></figure><h4 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a>LongAdder的成员变量</h4><p>LongAdder是Striped64 的子类，其有三个比较重要的成员函数，在之后的函数分析中需要使用到，这里先说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CPU的数量</span><br><span class="line">static final int NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">// Cell对象的数组，长度一般是2的指数</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 基础value值，当并发较低时，只累加该值</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 创建或者扩容Cells数组时使用的自旋锁变量</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure><p>cells是LongAdder的父类Striped64中的Cell数组类型的成员变量。每个Cell对象中都包含一个value值，并提供对这个value值的CAS操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class Cell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h4><p>我们首先来看一下LongAdder的add函数，其会多次尝试CAS操作将值进行累加，如果成功了就直接返回，失败则继续执行。代码比较复杂，而且涉及的情况比较多，我们就以梳理历次尝试CAS操作为主线，讲清楚这些CAS操作的前提条件和场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 当cells数组为null时，会进行第一次cas操作尝试。</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == null || </span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            // 当cells数组不为null，并且通过getProbe() &amp; m</span><br><span class="line">            // 定位的Cell对象不为null时进行第二次CAS操作。</span><br><span class="line">            // 如果执行不成功，则进入longAccumulate函数。</span><br><span class="line">            longAccumulate(x, null, uncontended); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用casBase函数，对base变量进行CAS累加。</p><p><img src="https://upload-images.jianshu.io/upload_images/623378-39fea917eb75cd7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>我们来看一下casBase函数相关的源码吧。我们可以认为变量base就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发量逐渐提高时，casBase函数会失败。如果cells数组为null或为空,就直接调用longAccumulate方法。因为cells为null或在为空，说明cells未</p><p>初始化，所以调用longAccumulate进行初始化。否则继续判断。<br> 如果cells中已经初始化，就继续进行后续判断。我们先来理解一下getProbe() &amp; m的这个操作吧，可以把这个操作当作一次计算”hash”值，然后将cells中这个位置的Cell对象赋值给变量a。如果变量a不为null，那么就调用该对象的cas方法去设置其value值。如果a为null，或在cas赋值发生冲突，那么调用longAccumulate方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/623378-8433413840b2a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><h4 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h4><p>longAccumulate函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想。</p><p> 首先，我们都知道只有当对base的cas操作失败之后，LongAdder才引入Cell数组．所以在longAccumulate中就是对Cell数组进行操作，分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作。</p><p> 在这段代码中，关于cellBusy的cas操作构成了一个SpinLock，这就是经典的SpinLock的编程技巧，大家可以学习一下。</p><p> 我们先来看一下longAccumulate的主体代码，首先是一个无限for循环，然后根据cells数组的状态来判断是要进行cells数组的初始化，还是进行对象添加或者扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                             boolean wasUncontended) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       if ((h = getProbe()) == 0) &#123; </span><br><span class="line">           //获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同</span><br><span class="line">           ThreadLocalRandom.current(); </span><br><span class="line">       //初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。</span><br><span class="line">           h = getProbe();</span><br><span class="line">           wasUncontended = true;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean collide = false;</span><br><span class="line">       for (;;) &#123; //cas经典无限循环，不断尝试</span><br><span class="line">           Cell[] as; Cell a; int n; long v;</span><br><span class="line">           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123; </span><br><span class="line">           // cells不为null,并且数组size大于0,表示cells已经初始化了</span><br><span class="line">           // 初始化Cell对象并设置到数组中或者进行数组扩容</span><br><span class="line">           &#125;</span><br><span class="line">           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">           //cells数组未初始化，获得cellsBusy lock,进行cells数组的初始化</span><br><span class="line">           // cells数组初始化操作</span><br><span class="line">           &#125;</span><br><span class="line">          //如果初始化数组失败了，那就再次尝试一下直接cas base变量，</span><br><span class="line">          // 如果成功了就直接返回，这是最后一个进行CAS操作的地方。</span><br><span class="line">           else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class="line">                                       fn.applyAsLong(v, x))))</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进行Cell数组代码如下所示，它首先调用casCellsBusy函数获取了cellsBusy‘锁’，然后进行数组的初始化操作，最后将cellBusy’锁’释放掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 注意在进入这段代码之前已经casCellsBusy获得cellsBusy这个锁变量了。</span><br><span class="line">boolean init = false;</span><br><span class="line">try &#123;</span><br><span class="line">    if (cells == as) &#123;</span><br><span class="line">        Cell[] rs = new Cell[2];</span><br><span class="line">        rs[h &amp; 1] = new Cell(x); //设置x的值为cell对象的value值</span><br><span class="line">        cells = rs;</span><br><span class="line">        init = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    cellsBusy = 0;</span><br><span class="line">&#125;</span><br><span class="line">if (init)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>如果Cell数组已经初始化过了，那么就进行Cell数组的设置或者扩容。这部分代码有一系列的if else的判断，如果前一个条件不成立，才会进入下一条判断。</p><p> 首先，当Cell数组中对应位置的cell对象为null时，表明该位置的Cell对象需要进行初始化，所以使用casCellsBusy函数获取’锁’，然后初始化Cell对象，并且设置进cells数组，最后释放掉’锁’。</p><p> 当Cell数组中对应位置的cell对象不为null，则直接调用其cas操作进行累加。</p><p> 当上述操作都失败后，认为多个线程在对同一个位置的Cell对象进行操作，这个Cell对象是一个“热点”，所以Cell数组需要进行扩容，将热点分散。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ((a = as[(n - 1) &amp; h]) == null) &#123; //通过与操作计算出来需要操作的Cell对象的坐标</span><br><span class="line">    if (cellsBusy == 0) &#123; //volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。</span><br><span class="line">    //当cellsBusy为0时，表示当前可以对cells数组进行操作。 </span><br><span class="line">        Cell r = new Cell(x);//将x值直接赋值给Cell对象</span><br><span class="line">        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;//如果这个时候cellsBusy还是0</span><br><span class="line">        //就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．</span><br><span class="line">        //如果失败了，就会再次执行一次循环</span><br><span class="line">            boolean created = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                Cell[] rs; int m, j;</span><br><span class="line">                //判断cells是否已经初始化，并且要操作的位置上没有cell对象．</span><br><span class="line">                if ((rs = cells) != null &amp;&amp;</span><br><span class="line">                    (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                    rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                    rs[j] = r;　//将之前创建的值为x的cell对象赋值到cells数组的响应位置．</span><br><span class="line">                    created = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉</span><br><span class="line">                //将cellBusy设置为0就是释放锁．</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (created)</span><br><span class="line">                break;　//如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value</span><br><span class="line">            continue; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = false; //未发生碰撞</span><br><span class="line">&#125;</span><br><span class="line">else if (!wasUncontended)//是否已经发生过一次cas操作失败</span><br><span class="line">    wasUncontended = true; //设置成true,以便第二次进入下一个else if 判断</span><br><span class="line">else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class="line">                            fn.applyAsLong(v, x))))</span><br><span class="line">    　//fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果</span><br><span class="line">    //就直接返回</span><br><span class="line">    break;</span><br><span class="line">else if (n &gt;= NCPU || cells != as)</span><br><span class="line">　　//如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．</span><br><span class="line">    collide = false;</span><br><span class="line">else if (!collide)</span><br><span class="line">    collide = true;</span><br><span class="line">else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">　　//再次获得cellsBusy这个spinLock,对数组进行resize</span><br><span class="line">    try &#123;</span><br><span class="line">        if (cells == as) &#123;//要再次检测as是否等于cells以免其他线程已经对cells进行了操作．</span><br><span class="line">            Cell[] rs = new Cell[n &lt;&lt; 1]; //扩容一倍</span><br><span class="line">            for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            cells = rs;//赋予cells一个新的数组对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cellsBusy = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = false;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br><span class="line">h = advanceProbe(h);//由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>后记<br> 本篇文章写的不是很好，我写完之后又看了一遍coolshell上的关于LongAdder的文章，感觉自己没有人家写的那么简洁明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章来源： https://yq.aliyun.com/articles/688822</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LongAdder解析&quot;&gt;&lt;a href=&quot;#LongAdder解析&quot; class=&quot;headerlink&quot; title=&quot;LongAdder解析&quot;&gt;&lt;/a&gt;LongAdder解析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p1.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;摘要： 对`LongAdder`的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于`AtomicLong`来说，更加适合写多读少的并发情景。今天，我们就研究一下`LongAdder`的原理，探究一下它如此高效的原因。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>java并发计数器分析</title>
    <link href="https://www.zengmanhua.cn/2019/05/22/java%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>https://www.zengmanhua.cn/2019/05/22/java并发计数器分析/</id>
    <published>2019-05-22T11:04:00.000Z</published>
    <updated>2019-06-11T04:28:05.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p12.jpg" alt></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><pre><code>一提到线程安全的并发计数器，AtomicLong 必然是第一个被联想到的工具。Atomic* 一系列的原子类以及它们背后的 CAS 无锁算法，常常是高性能，高并发的代名词。本文将会阐释，在并发场景下，使用 AtomicLong 来充当并发计数器将会是一个糟糕的设计，实际上存在不少 AtomicLong 之外的计数器方案。近期我研究了一些 Jdk1.8 以及 JCTools 的优化方案，并将它们的对比与实现细节整理于此。</code></pre><a id="more"></a><h4 id="AtomicLong-的前世今生"><a href="#AtomicLong-的前世今生" class="headerlink" title="AtomicLong 的前世今生"></a>AtomicLong 的前世今生</h4><pre><code>在 Java 中，Atomic* 是高效的，这得益于 sun.misc.Unsafe 提供的一系列底层 API，使得 Java 这样的高级语言能够直接和硬件层面的 CPU 指令打交道。并且在 Jdk1.7 中，这样的底层指令可以配合 CAS 操作，达到 Lock-Free。在 Jdk1.7 中，AtomicLong 的关键代码如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        long current = get();</span><br><span class="line">        long next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(long expect, long update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. get() 方法 volatile 读当前 long 值2. 自增3. 自旋判断新值与当前值4. 自旋成功，返回；否则返回 1我们特别留意到 Jdk1.7 中 unsafe 使用的方法是 compareAndSwapLong，它与       x86 CPU 上的 LOCK CMPXCHG 指令对应，并且在应用层使用 while(true) 完成自     旋，这个细节在 Jdk1.8 中发生了变化。在 Jdk1.8 中，AtomicLong 的关键代码如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">return unsafe.getAndAddLong(this, valueOffset, 1L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk1.7 的 CAS 操作已经不复存在了，转而使用了 getAndAddLong 方法，它与 x86 CPU 上的 LOCK XADD 指令对应，以原子方式返回当前值并递增（fetch and add）。</p><figure class="highlight plain"><figcaption><span>Atomic* 高效的原因，回答 CAS 是不够全面且不够严谨的，Jdk1.7 的 unsafe.compareAndSwapLong 以及 Jdk1.8 的 unsafe.getAndAddLong 才是关键，且 Jdk1.8 中不存在 CAS。 ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Jdk1.8 AtomicLong 相比 Jdk1.7 AtomicLong 的表现是要优秀的，这点我们将在后续的测评中见证。</span><br><span class="line"></span><br><span class="line">#### Jdk1.8 AtomicLong 相比 Jdk1.7 AtomicLong 的表现是要优秀的，这点我们将在后续的测评中见证。</span><br><span class="line"></span><br><span class="line">无论在 Jdk1.7 还是 Jdk1.8 中，Atomic* 的开销都是很大的，主要体现在：</span><br></pre></td></tr></table></figure><ol><li><p>高并发下，CAS 操作可能会频繁失败，真正更新成功的线程占少数。(Jdk1.7 独有的问题)</p></li><li><p>我之前的文章中介绍过“伪共享” (false sharing) 问题，但在 CAS 中，问题则表现的更为直接，这是“真共享”，与”伪共享“存在相同的问题：缓存行失效，缓存一致性开销变大。</p></li><li><p>底层指令的开销不见得很低，无论是 LOCK XADD 还是 LOCK CMPXCHG，想深究的朋友可以参考 instruction_tables ，（这一点可能有点钻牛角尖，但不失为一个角度去分析高并发下可行的优化）</p></li><li><p>Atomic<em> 所做的，比我们的诉求可能更大，有时候我们只需要计数器具备线程安全地递增这样的特性，但 Atomic</em> 的相关操作每一次都伴随着值的返回。他是个带返回值的方法，而不是 void 方法，而多做了活大概率意味着额外的开销。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">抛开上述导致 AtomicLong 慢的原因，AtomicLong 仍然具备优势：</span><br></pre></td></tr></table></figure></p></li><li><p>上述的第 4 点换一个角度也是 AtomicLong 的有点，相比下面要介绍的其他计数器方案，AtomicLong 能够保证每次操作都精确的返回真实的递增值。你可以借助 AtomicLong 来做并发场景下的递增序列号方案，注意，本文主要讨论的是计数器方案，而不是序列号方案。</p></li><li><p>实现简单，回到那句话：“简单的架构通常性能不高，高性能的架构通常复杂度很高”，AtomicLong 属于性能相对较高，但实现极其简单的那种方案，因为大部分的复杂性，由 JMM 和 JNI 方法屏蔽了。相比下面要介绍的其他计数器实现，AtomicLong 真的太“简易”了。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![upload successful](http://47.103.200.134/image/AtomicLongSpeet.png)</span><br></pre></td></tr></table></figure></p></li></ol><p>横向对比，写的性能相比读的性能要差很多，在 20 个线程下写性能比读性能差距了 4~5 倍。</p><p>纵向对比，主要关注并发写，线程竞争激烈的情况下，单次自增耗时从 22 ns 增长为了 488 ns，有明显的性能下降。</p><p>实际场景中，我们需要统计系统的 qps、接口调用次数，都需要使用到计数的功能，写才是关键，并不是每时每刻都需要关注自增后的返回值，而 AtomicLong 恰恰在核心的写性能上有所欠缺。由此引出其他计数器方案。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 认识 LongAdder</span><br><span class="line">Doug Lea 在 JDK1.8 中找到了一个上述问题的解决方案，他实现了一个 LongAdder 类。</span><br></pre></td></tr></table></figure></p><p>@since 1.8<br>@author Doug Lea<br>public class LongAdder extends Striped64 implements Serializable {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LongAdder 的 API 如下</span><br><span class="line"></span><br><span class="line">![upload successful](http://47.103.200.134/image/longAddr.png)</span><br><span class="line"></span><br><span class="line">你应当发现，LongAdder 和 AtomicLong 明显的区别在于，increment 是一个 void 方法。直接来看看 LongAdder 的性能表现如何。(LA = LongAdder, AL = AtomicLong, 单位 ns/op)</span><br><span class="line"></span><br><span class="line">![upload successful](http://47.103.200.134/image/longAddrSpett.png)</span><br><span class="line"></span><br><span class="line">我们从中可以发现一些有意思的现象，网上不少很多文章没有从读写上对比二者，直接宣称 LongAdder 性能优于 AtomicLong，其实不太严谨。在单线程下，并发问题没有暴露，两者没有体现出差距；随着并发量加大，LongAdder 的 increment 操作更加优秀，而 AtomicLong 的 get 操作则更加优秀。鉴于在计数器场景下的特点—写多读少，所以写性能更高的 LongAdder 更加适合。</span><br><span class="line"></span><br><span class="line">#### LongAdder 写速度快的背后</span><br><span class="line"></span><br><span class="line">网上分析 LongAdder 源码的文章并不少，我不打算详细分析源码，而是挑选了一些必要的细节以及多数文章没有提及但我认为值得分析的内容。</span><br><span class="line"></span><br><span class="line">![upload successful](http://47.103.200.134/image/cell.png)</span><br></pre></td></tr></table></figure></p><ol><li>Cell 设计减少并发修改时的冲突<br>在 LongAdder 的父类 Striped64 中存在一个 volatile Cell[] cells; 数组，其长度是 2 的幂次方，每个 Cell 都填充了一个 @Contended 的 Long 字段，为了避免伪共享问题。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` @sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    // ... ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><figcaption><span>通过一系列算法，将计数结果分散在了多个 Cell 中，Cell 会随着并发量升高时发生扩容，最坏情况下 Cell </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">public long sum() &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    long sum = base;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>ConcurrentHashMap 中的 size() 中也存在，毕竟他们的作者都是 Doug Lea。```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>并发场景下高效获取随机数</li></ol><p>LongAdder 内部算法需要获取随机数，而 Random 类在并发场景下也是可以优化的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>ThreadLocalRandom random =  ThreadLocalRandom.current();<br>random.nextInt(5);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```使用 ThreadLocalRandom 替代 Random，同样出现在了 LongAdder 的代码中。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. longAccumulate</span><br><span class="line">longAccumulate 方法是 LongAdder 的核心方法，内部存在大量的分支判断。首先和 Jdk1.7 的 AtomicLong 一样，它使用的是 UNSAFE.compareAndSwapLong 来完成自旋，不同之处在于，其在初次 cas 方式失败的情况下(说明多个线程同时想更新这个值)，尝试将这个值分隔成多个 Cell，让这些竞争的线程只负责更新自己所属的 Cell，这样将竞争压力分散开。</span><br></pre></td></tr></table></figure><h4 id="LongAdder-的前世今生"><a href="#LongAdder-的前世今生" class="headerlink" title="LongAdder 的前世今生"></a>LongAdder 的前世今生</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实在 Jdk1.7 时代，LongAdder 还未诞生时，就有一些人想着自己去实现一个高性能的计数器了，比如一款 Java 性能监控框架 dropwizard/metrics 就做了这样事，在早期版本中，其优化手段并没有 Jdk1.8 的 LongAdder 丰富，而在 metrics 的最新版本中，其已经使用 Jdk1.8 的 LongAdder 替换掉了自己的轮子。在最后的测评中，我们将 metrics 版本的 LongAdder 也作为一个参考对象。</span><br></pre></td></tr></table></figure><h4 id="JCTools-中的-ConcurrentAutoTable"><a href="#JCTools-中的-ConcurrentAutoTable" class="headerlink" title="JCTools 中的 ConcurrentAutoTable"></a>JCTools 中的 ConcurrentAutoTable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并非只有 LongAdder 考虑到了并发场景下计数器的优化，大名鼎鼎的并发容器框架 JCTool 中也提供了和今天主题相关的实现，虽然其名称和 Counter 看似没有关系，但通过其 Java 文档和 API ，可以发现其设计意图考虑到了计数器的场景。</span><br></pre></td></tr></table></figure><p><img src="http://47.103.200.134/image/ConcurrentAutoTable%20.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最后的测评中，我们将 JCTools 的 ConcurrentAutoTable 也作为一个参考对象。</span><br></pre></td></tr></table></figure></p><h4 id="最终测评"><a href="#最终测评" class="headerlink" title="最终测评"></a>最终测评</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jdk1.7 的 AtomicLong，Jdk1.8 的 AtomicLong，Jdk 1.8 的 LongAdder，Metrics 的 LongAdder，JCTools 的 ConcurrentAutoTable，我对这五种类型的计数器使用 JMH 进行基准测试。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Counter &#123;</span><br><span class="line">    void inc();</span><br><span class="line">    long get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 5 个类都适配成 Counter 接口的实现类，采用 @State(Scope.Group)，@Group 将各组测试用例进行隔离，尽可能地排除了互相之间的干扰，由于计数器场景的特性，我安排了 20 个线程进行并发写，1 个线程与之前的写线程共存，进行并发读。Mode=avgt 代表测试的是方法的耗时，越低代表性能越高。</span><br></pre></td></tr></table></figure><p><img src="http://47.103.200.134/image/test.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果我们只关注 inc 即写性能，可以发现 jdk1.8 的 LongAdder 表现的最为优秀，ConcurrentAutoTable 以及两个版本的 LongAdder 在一个数量级之上；1.8 的 AtomicLong 相比 1.7 的 AtomicLong 优秀很多，可以得出这样的结论，1.7 的 CAS+LOCK CMPXCHG 方案的确不如 1.8 的 LOCK XADD 来的优秀，但如果与特地优化过的其他计数器方案来进行比较，便相形见绌了。</span><br><span class="line"></span><br><span class="line">如果关注 get 性能，虽然这意义不大，但可以见得，AtomicLong 的 get 性能在高并发下表现依旧优秀，而 LongAdder 组合求值的特性，导致其性能必然存在一定下降，位列第二梯队，而 ConcurrentAutoTable 的并发读性能最差。</span><br><span class="line"></span><br><span class="line">关注整体性能，CounterBenchmark.rw 是对一组场景的整合打分，可以发现，在我们模拟的高并发计数器场景下，1.8 的 LongAdder 获得整体最低的延迟 98 ns，相比性能最差的 Jdk1.7 AtomicLong 实现，高了整整 10 倍有余，并且，随着并发度提升，这个数值还会增大。</span><br></pre></td></tr></table></figure><h4 id="AtomicLong-可以被废弃吗？"><a href="#AtomicLong-可以被废弃吗？" class="headerlink" title="AtomicLong 可以被废弃吗？"></a>AtomicLong 可以被废弃吗？</h4><p>既然 LongAdder 的性能高出 AtomicLong 这么多，我们还有理由使用 AtomicLong 吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文重点讨论的角度还是比较局限的：单机场景下并发计数器的高效实现。AtomicLong 依然在很多场景下有其存在的价值，例如一个内存中的序列号生成器，AtomicLong 可以满足每次递增之后都精准的返回其递增值，而 LongAdder 并不具备这样的特性。LongAdder 为了性能而丧失了一部分功能，这体现了计算机的哲学，无处不在的 trade off。</span><br></pre></td></tr></table></figure><h4 id="高性能计数器总结"><a href="#高性能计数器总结" class="headerlink" title="高性能计数器总结"></a>高性能计数器总结</h4><ul><li><p>AtomicLong ：并发场景下读性能优秀，写性能急剧下降，不适合作为高性能的计数器方案。内存需求量少。</p></li><li><p>LongAdder ：并发场景下写性能优秀，读性能由于组合求值的原因，不如直接读值的方案，但由于计数器场景写多读少的缘故，整体性能在几个方案中最优，是高性能计数器的首选方案。由于 Cells 数组以及缓存行填充的缘故，占用内存较大。</p></li><li><p>ConcurrentAutoTable ：拥有和 LongAdder 相近的写入性能，读性能则更加不如 LongAdder。它的使用需要引入 JCTools 依赖，相比 Jdk 自带的 LongAdder 并没有优势。但额外说明一点，ConcurrentAutoTable 的使用并非局限于计数器场景，其仍然存在很大的价值。</p></li></ul><p><strong><em>在前面提到的性能监控框架 Metrics，以及著名的熔断框架 Hystrix 中，都存在 LongAdder 的使用场景，有兴趣的朋友快去实践一下 LongAdder 吧。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">本文所有的 JMH 测试代码，均可在我的 github 中获得：https://github.com/lexburner/JMH-samples.git</span><br><span class="line"></span><br><span class="line">微信不支持外部超链接，文中相关仓库附录：</span><br><span class="line"></span><br><span class="line">Netflix/Hystrix : https://github.com/Netflix/Hystrix</span><br><span class="line"></span><br><span class="line">Metrics : https://github.com/dropwizard/metrics</span><br><span class="line"></span><br><span class="line">JCTools : https://github.com/JCTools/JCTools</span><br><span class="line"></span><br><span class="line">instruction_tables : https://www.agner.org/optimize/instruction_tables.pdf</span><br><span class="line"></span><br><span class="line">本文转载于：https://mp.weixin.qq.com/s/yAvJFZWxfKb38IDMjQd5zg?spm=a2c4e.11153940.blogcont651530.11.303e7bebu6FTOM</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p12.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;一提到线程安全的并发计数器，AtomicLong 必然是第一个被联想到的工具。Atomic* 一系列的原子类以及它们背后的 CAS 无锁算法，常常是高性能，高并发的代名词。本文将会阐释，在并发场景下，使用 AtomicLong 来充当并发计数器将会是一个糟糕的设计，实际上存在不少 AtomicLong 之外的计数器方案。近期我研究了一些 Jdk1.8 以及 JCTools 的优化方案，并将它们的对比与实现细节整理于此。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之基础知识</title>
    <link href="https://www.zengmanhua.cn/2019/05/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.zengmanhua.cn/2019/05/21/并发编程之基础知识/</id>
    <published>2019-05-21T07:11:40.000Z</published>
    <updated>2019-06-11T04:28:51.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lombox"><a href="#Lombox" class="headerlink" title="Lombox"></a>Lombox</h3><p><img src="http://47.103.200.134/image/p13.jpg" alt></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Lombok项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能val，等等。</p><a id="more"></a><p>除了官方介绍中，并不多相关文章，特意挑了 <strong><em>一篇文章中相关内容</em></strong></p><pre><code>lombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码。特别是相对于 POJO。简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。</code></pre><h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><p>@slf4j、@Setter、@Getter、@NoArgsConstructor(注解在类上：为类提供一个无参的构造方法)、@AllArgsConstructor(注解在类上；为类提供一个全参的构造方法)</p><pre><code>@NoArgsConstructor //注解在类上：为类提供一个无参的构造方法@AllArgsConstructor//注解在类上；为类提供一个全参的构造方法public class Person {  //@Getter @Setter 注解在属性上；为属性提供 setting 方法 getting方法  @Setter @Getter private int pid;  @Setter @Getter private String pname;  @Setter @Getter private int sage; }</code></pre><h3 id="基础知识讲解与核心知识准备"><a href="#基础知识讲解与核心知识准备" class="headerlink" title="基础知识讲解与核心知识准备"></a>基础知识讲解与核心知识准备</h3><h4 id="并发与高并发基本概念"><a href="#并发与高并发基本概念" class="headerlink" title="并发与高并发基本概念"></a>并发与高并发基本概念</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><pre><code>并发：同时拥有两个或者多个线程，如果程序在单核处理器运行，多个线程将交替地换入或者换出内存，这些线程是同时&quot;存在&quot;的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将会分配到一个处理器核上，因此可以同时运行并行：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；并发是并行的子集。如果说并发就是在一台处理器上&quot;同时&quot;处理多个任务，那么并行就是在多台处理器上同时处理多个任务；个人理解是，在单核CPU系统上，并行是无法实现的，只可能存在并发而不可能存在并行。</code></pre><p>    高并发：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常指，通过设计保证系统能够同时并行处理很多请求。</p><h5 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h5><pre><code>并发：多个线程操作相同的资源，保证线程安全，合理使用资源高并发：服务能同时处理很多请求，提高程序性能；如系统集中收到大量的请求（12306的抢票系统），导致系统在某段时间类执行大量的操作，包括对资源的请求、数据库的操作等等，如果高并发处理不好，不仅仅降低用户的体验度，请求时间变长，同时也可能导致系统宕机，甚至导致OOM（Out Of Memory）异常，如果想要系统适应高并发状态，就要有多个方面进行系统优化，包括硬件、网络、系统架构、开发语言的选取、数据结构的应用、算法的优化等等，这个时候谈论的是如何提供现有程序的性能，对高并发场景提供一些解决方案、手段等等</code></pre><h5 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h5><pre><code>在多线程并发环境下，如果不采取特殊手段，普通的累加结果很可能是错的。错的原因可能涉及到计算机原理以及JAVA方面的一些知识。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9577794-40a2a48a0a75d1df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>Main Memory : 主存Cache : 高速缓存，数据的读取和存储都经过此高速缓存CPU Core :  CPU核心Bus :  系统总线  CUP Core 与 Cache 之间有一条快速通道，Main Memory 与 Cache 关联在 Bus 上，同时 Bus 还用于其他组件 的通信，在Cache出现不久后，系统变得更加复杂，Cache与Main Memory中速度的差异拉大，直到加入另一级的Cache，新加入的Cache 比 一级 Cache 更大，但是更慢，由于从加大一级Cache的做法，从经济上是行不通的，所以有了二级Cache，甚至已经有三级 Cache</code></pre><h5 id="为什么需要CPU-CACHE"><a href="#为什么需要CPU-CACHE" class="headerlink" title="为什么需要CPU CACHE?"></a>为什么需要CPU CACHE?</h5><pre><code>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，这样会使CPU花费很长时间等待数据到来或把数据写入内存。所以Cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：CPU - &gt; CACHE - &gt; MEMORY）</code></pre><h5 id="CPU-CACHE-意义"><a href="#CPU-CACHE-意义" class="headerlink" title="CPU CACHE 意义"></a>CPU CACHE 意义</h5><pre><code>缓存的容量远远小于主存，因此出现缓存不命中的情况在所难免，既然缓存不能包含CPU所需要的所有数据，那么Cache的存在真的有意义吗?CPU缓存存在的意义分两点（局部性原理）：时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问空间局限性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问  缓存的工作原理是当CPU要读取一个数据时，首先从缓存中查找，如果找到就立即读取并运送给CPU处理；如果没有找到，就用相对慢的速度内存中读取并运送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。  正是这样的读取机制使CPU读取缓存的命中率非常高（大多数CPU可达90%左右），也就是说CPU下一次要读取的数据90%都在缓存中，大约10%需要从内存读取。</code></pre><h5 id="缓存一致性（MESI）"><a href="#缓存一致性（MESI）" class="headerlink" title="缓存一致性（MESI）"></a>缓存一致性（MESI）</h5><pre><code>缓存一致性用于保证多个CPU Cache之间缓存共享数据的一致性，定义了Cache Line四种状态，而CPU对Cache的四种操作，可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候 ，需要对Cache Line作出相应的修改，从而保证数据在多个缓存之间的一致性  Cache Line ： 是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。  MESI其实是四种状态的缩写：M（modify）修改、E（exclusive）独占、S（shared）共享、I（invalid）失效。  Cache 操作： MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），通过监听也知道其他CPU中cache的操作（remote read和remote write）。对于自己本地缓存有的数据，CPU仅需要发起local操作，否则发起remote操作，从主存中读取数据，cache控制器通过总线监听，仅能够知道其他CPU发起的remote操作，但是如果local操作会导致数据不一致性，cache控制器会通知其他CPU的cache控制器修改状态。</code></pre><h5 id="乱序执行优化"><a href="#乱序执行优化" class="headerlink" title="乱序执行优化"></a>乱序执行优化</h5><pre><code>处理器为提高运算速度而做出违背代码原有顺序的优化举个例子：计算 a * b ，a =10 ，b = 200 ，则 result = a * b = 2000代码编写顺序：a=10 -&gt; b=200 -&gt; result = a * bCPU乱序执行优化可能会发生执行顺序为：b=200 -&gt; a=10 -&gt; result = a * bCPU乱序执行优化不会对结果造成影响，在单核时代，处理器保证做出的优化，不会导致执行的结果远离预期的目标，但是在多核环境下并非如此。首先在多核环境中，同时会有多个核执行指令，每个核的指定都可能会被乱序优化，另外，处理器还引用了L1、L2等缓存机制，每个核都有自己的缓存，这就导致了逻辑次序上后写入内存的数据，未必真的最后写入，最终带来了这样的一个问题：如果我们不做任何防护措施，处理器最终得到的结果和我们逻辑得出的结果大不相同。比如我们在其中的一个核中执行数据写入操作，并在最后写一个标记，用来标记数据已经准备好了，然后从另外一个核上，通过那个标志，来判断数据是否已经就绪，这种做法它就存在一定的风险，标记位先被写入，但数据操作并未完成（可能是计算为完成、也可能是数据没有从缓存刷新到主存当中）， 最终导致另外的核使用了错误的数据。</code></pre><h5 id="Java-内存模型（Java-Memory-Model，JMM）"><a href="#Java-内存模型（Java-Memory-Model，JMM）" class="headerlink" title="Java 内存模型（Java Memory Model，JMM）"></a>Java 内存模型（Java Memory Model，JMM）</h5><pre><code>CPU缓存一致性和乱序执行优化，在多核多并发下，需要额外做很多的事情，才能保证程序的执行，符合我们的预期。那么JVM（Java Virtual Machine (Java虚拟机)）是如何解决这些问题的?为了屏蔽掉各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台下都能达到一致的并发效果，JMV规范中定义了JMM （Java Memory Model (Java 内存模型)）。 JMM是一种规范，它规范了JVM与计算机内存是如何协同工作的，它规定一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步的访问共享变量。</code></pre><h5 id="JVM内存分配概念"><a href="#JVM内存分配概念" class="headerlink" title="JVM内存分配概念"></a>JVM内存分配概念</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-e9d8060908de35f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>JVM内存分配的两个概念：Stack（栈）和Heap（堆）。  Java中的Heap是运行时数据区，由垃圾回收负责，它的优势是动态的分配内存大小，生存期也不必事先告诉编译器，在运行时动态分配内存，Java的垃圾收集器，会自动回收不再使用的数据。但是也有缺点，由于是要在运行时动态分配内存，因此存取速度相对较慢。  Java中的Stack优势是存取速度比Heap要快，仅次于计算机中的寄存器，栈中的数据是可以共享的，但是它的缺点是，存在栈中数据的大小和生存期必须是确定的，缺乏灵活性，主要存放一些基本类型的变量。  JMM要求调用栈和本地变量存放在线程栈中，对象存放在堆上。一个本地变量可能指向一个对象的引用，引用这个本地变量是存放在线程栈上，而对象本身是存放在堆上的。一个对象可能包含方法，这些方法可能包含本地变量，这些本地变量还是存放在线程栈中，即使这些方法所属的对象存放在堆上。一个对象的成员变量可能会随着这个对象自身存放在堆上，不管这个成员对象是原始类型还是引用类型，静态成员变量跟随着类的定义一起存放在堆上。存放在堆上的对象，可以被所持有对这个对象引用线程的访问。  当一个线程可以访问一个对象的时候，它也可以访问该对象的成员变量，如果两个线程同时调用同一个对象的同一个方法，将会都访问该对象的成员变量，但是每一个线程都拥有了这个成员变量的私有拷贝。</code></pre><h5 id="计算机内存硬件架构"><a href="#计算机内存硬件架构" class="headerlink" title="计算机内存硬件架构"></a>计算机内存硬件架构</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-63c75dfa96cdfd1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="upload successful"></p><pre><code>CPU，一台现代计算机拥有两个或多个CPU，其中一些CPU还有多核，从这一点可以看出，在一个有两个或多个CPU的现代计算机上，同时运行多个线程是非常有可能的，而且每个CPU在某一个时刻，运行一个线程是肯定没有问题的，这意味着，如果Java程序是多线程的，在Java程序中，每个CPU上一个线程是可能同时并发执行的。  CPU Refisters（寄存器），每个CPU都包含一系列的寄存器，它们是CPU内存的基础，CPU在寄存器中执行操作的速度远大于在主存上执行的速度，这是因为CPU访问寄存器的速度远大于主存。  Cache（高速缓存），由于计算机的存储设备与处理器运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速的进行，当运算结束后，在从缓存同步到内存中。这样处理器就无需等待缓慢的内存读写，CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。  Main Memory（主存），随机存取存储器（random access memory，RAM）又称作“随机存储器&quot;，一个计算机包含一个主存，所有的CPU都可以访问主存，主存通常比CPU中的缓存大得多。</code></pre><h5 id="JVM-与-Computer"><a href="#JVM-与-Computer" class="headerlink" title="JVM 与 Computer"></a>JVM 与 Computer</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-8687192be85206f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>JVM 与 Computer 内存架构存在差异，硬件内存并无区分栈与堆，对于硬件而言，所有的栈和堆都分布在主内存中，可能会出现在高速缓存、寄存器中。</code></pre><h5 id="内存模型抽象结构"><a href="#内存模型抽象结构" class="headerlink" title="内存模型抽象结构"></a>内存模型抽象结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-ef8f9cbb9a839f3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" alt="upload successful"></p><h5 id="Java内存模型-同步八种操作"><a href="#Java内存模型-同步八种操作" class="headerlink" title="Java内存模型 - 同步八种操作"></a>Java内存模型 - 同步八种操作</h5><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值存放工作内存的变量副本中</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存中，以便随后的write的操作</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ul><h5 id="Java内存模型-同步规则"><a href="#Java内存模型-同步规则" class="headerlink" title="Java内存模型 - 同步规则"></a>Java内存模型 - 同步规则</h5><ol><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作，但Java内存模型只要求上述操作必须按顺序执行，而没有保证是连续执行</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次与执行lock后，只有执行相同次数的unlock，变量才会被解锁。lock和unlock必须成对出现</li><li>如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把变量同步到主内存中（执行store和write操作）</li></ol><h5 id="Java-内存模型-同步操作与规则"><a href="#Java-内存模型-同步操作与规则" class="headerlink" title="Java 内存模型 - 同步操作与规则"></a>Java 内存模型 - 同步操作与规则</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-60bc2de2383c6545.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><h5 id="并发的优势与风险"><a href="#并发的优势与风险" class="headerlink" title="并发的优势与风险"></a>并发的优势与风险</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-6908ee45fdcfd1dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><h5 id="并发编程与线程安全"><a href="#并发编程与线程安全" class="headerlink" title="并发编程与线程安全"></a>并发编程与线程安全</h5><pre><code>代码所在的进程，有多个线程同时运行，而这些线程可能会同时运行同一段代码，如果每次运行结果和单线程预期结果一致，变量值也和预期一致，则认为这是线程安全的。简单的说，就是并发环境下，得到我们期望正确的结果。对应的一个概念就是线程不安全，就是不提供数据访问保护，有可能出现多个线程，先后更改数据，造成所得到的数据是脏数据，也可能是计算错误。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lombox&quot;&gt;&lt;a href=&quot;#Lombox&quot; class=&quot;headerlink&quot; title=&quot;Lombox&quot;&gt;&lt;/a&gt;Lombox&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p13.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Lombok项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能val，等等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>时光荏苒，蹉跎了谁的年华</title>
    <link href="https://www.zengmanhua.cn/2019/05/18/%E6%97%B6%E5%85%89%E8%8D%8F%E8%8B%92%EF%BC%8C%E8%B9%89%E8%B7%8E%E4%BA%86%E8%B0%81%E7%9A%84%E5%B9%B4%E5%8D%8E/"/>
    <id>https://www.zengmanhua.cn/2019/05/18/时光荏苒，蹉跎了谁的年华/</id>
    <published>2019-05-18T10:04:15.000Z</published>
    <updated>2019-06-11T04:29:44.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://47.103.200.134/image/p14.jpg" alt="输入图片说明"></p><p><strong>当清晨的一缕阳光透过窗帘上的空隙映照在沉睡的脸庞时，微微张开的双眼朦胧地注视着周遭的一切，新的一天悄然而至。</strong> </p><p>　　 <strong>——题记</strong> </p><a id="more"></a><pre><code>时光的单车飞快驶去，岁月的倒影也将消失，白天与黑夜不停的交替，轮回的四季斑驳了谁的岁月，蹉跎了谁的年华。一个人静静地与岁月交错，于平淡之中细细体会生活的深意，去注视，去聆听，去感受那些带着希望的别离以及那些经受沧桑的相逢，不论时光如何飞转，那些落花一样的往事，依然鲜活地存在于我的脑海之中。当岁月和美丽的回忆已成为风中的叹息，我们伤感的眼里也许依然残存旧时的泪痕，模糊了视线，不敢轻易触碰。生活的列车慢慢的前进，有些人下去，也有人上去，不慌不忙的过着行云流水的日子，有的人知道自己的前方在哪里停靠，生活充实而安逸，有些人庸庸碌碌的过着不起波澜的日子，每天无头鸟似的瞎忙，朦胧的眼神向世界宣告着昏暗思想，一个个皮囊悬浮在空气中，没有生机的灵魂过着糜烂的时间。没有归属，无处生根。有时我们在迷茫青春的时候，日子也慢慢地溜走，不留一点痕迹。时光不可阻挡，岁月交错中总要有些思量。人生只有在不短的思考中才会有所进步，有所追求，有了目标的人生才不会孤独和无助，只有让自己的心静下来时一些前方的东西才会明朗的展现在我们的面前。让我们不再迷惑于为所谓的挣扎中，谁的年华没有色彩，谁的青春没有耀眼的光芒，只是在岁月的长河里我们的选择不同，所得到的结局就不同，每个人都需要努力才会得到一切自己所要追求的东西和梦想。生命无常，人生苦短，记忆的时光中我们匆匆走过，走过喧嚣，走过孤寂，时光无情地带走了我们的青春年少，还好我们都在坚持着内心的宁静，岁月的年轮缓缓的从我们身边碾过，往事一幕幕铺陈，让我的生活回忆不至于那么的枯燥，一些美好的记忆还依然鲜活地根植在我的脑海之中。消逝不去，本不该怀旧的年纪，可是我们学不会遗忘，日日夜夜的想念，带着些许的小寂寞，心有不甘常常在无人的街角大声的长啸，发泄着内心的声音，有时候我们会选择相信宿命，认为人与人之间的相遇，就像是上天早已做了安排，人谁也逃不过岁月时光刻下的印迹。时光荏苒，蹉跎了谁的年华，匆匆行走的岁月长河中，有些人只顾着追寻他人的脚步，忘记了自己的方向，忘记了自己的目标和理想，有些人几顾思量不敢走出自己的道路，因而迷失了方向。迷失了自己。有些人默默坚守，把青春的岁月包裹在温热的怀里，载着它踏上梦想的征途，不留一丝遗憾。不留一点别人靠近的距离，就像是陈孝正为自己规划的一厘米的差距，人生没有从头来过的权利。亦没有后悔的权利，做过的事情，不管有些怎样的结局都会成为过往，我们纵使一味的活在过去的时光里也不会改变一点点发生的故事，向着远方，努力的看看前方的路才是对我们自己的肯定，只有心存希望，才会有拼搏的勇气，才有希望去走更远的路，因为值得，所以一路前行，那一路上的心酸往事，慢慢的沉淀在内心平和的深处！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://47.103.200.134/image/p14.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当清晨的一缕阳光透过窗帘上的空隙映照在沉睡的脸庞时，微微张开的双眼朦胧地注视着周遭的一切，新的一天悄然而至。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;——题记&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.zengmanhua.cn/categories/life/"/>
    
    
      <category term="生活" scheme="https://www.zengmanhua.cn/tags/life/"/>
    
  </entry>
  
</feed>
