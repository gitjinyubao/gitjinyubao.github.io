<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JinYuBao</title>
  
  <subtitle>生活源于奋斗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zengmanhua.cn/"/>
  <updated>2019-05-24T02:29:29.435Z</updated>
  <id>https://www.zengmanhua.cn/</id>
  
  <author>
    <name>Jin Yu Bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存溢出&amp;&amp;栈溢出</title>
    <link href="https://www.zengmanhua.cn/2019/05/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.zengmanhua.cn/2019/05/24/内存溢出-栈溢出/</id>
    <published>2019-05-24T02:02:54.000Z</published>
    <updated>2019-05-24T02:29:29.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存溢出-amp-amp-栈溢出"><a href="#内存溢出-amp-amp-栈溢出" class="headerlink" title="内存溢出&amp;&amp;栈溢出"></a>内存溢出&amp;&amp;栈溢出</h3><p><img src="http://prl6c63q7.bkt.clouddn.com/p5.jpg" alt></p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><a id="more"></a><h5 id="内存溢出的原因是什么？"><a href="#内存溢出的原因是什么？" class="headerlink" title="内存溢出的原因是什么？"></a>内存溢出的原因是什么？</h5><p>内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。如果出现这种现象可行代码排查：</p><ul><li><p>是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0; //public static String str;</p></li><li><p>是否 应用 中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）</p></li><li><p>是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）</p></li><li><p>检查 应用 中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。</p></li><li><p>检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。</p></li><li><p>检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行”+”就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如String s1 = &quot;My name&quot;;</span><br><span class="line"></span><br><span class="line">String s2 = &quot;is&quot;;</span><br><span class="line"></span><br><span class="line">String s3 = &quot;xuwei&quot;;</span><br><span class="line"></span><br><span class="line">String str = s1 + s2 + s3 +.........;这是会容易造成内存溢出的</span><br><span class="line"></span><br><span class="line">但是String str =  &quot;My name&quot; + &quot; is &quot; + &quot; xuwei&quot; + &quot; nice &quot; + &quot; to &quot; + &quot; meet you&quot;; //但是这种就不会造成内存溢出。因为这是”字面量字符串“，在运行&quot;+&quot;时就会在编译期间运行好。不会按照JVM来执行的。</span><br><span class="line"></span><br><span class="line">在使用String,StringBuffer,StringBuilder时，如果是字面量字符串进行&quot;+&quot;时，应选用String性能更好；如果是String类进行&quot;+&quot;时，在不考虑线程安全时，应选用StringBuilder性能更好。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHeap</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;  <span class="comment">//死循环一直创建对象，堆溢出</span></span><br><span class="line">              ArrayList list = <span class="keyword">new</span> ArrayList (<span class="number">2000</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;  <span class="comment">//无出口的递归调用，栈溢出</span></span><br><span class="line">        num++;  </span><br><span class="line">        <span class="keyword">this</span>.testStack();  </span><br><span class="line">     &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Test  t  = <span class="keyword">new</span> Test ();  </span><br><span class="line">        t.testHeap();  </span><br><span class="line">        t.testStack();     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈溢出的原因"><a href="#栈溢出的原因" class="headerlink" title="栈溢出的原因"></a>栈溢出的原因</h4><ul><li><p>是否有递归调用</p></li><li><p>是否有大量循环或死循环</p></li><li><p>全局变量是否过多</p></li><li><p>数组、List、map数据是否过大</p></li><li><p>使用DDMS工具进行查找大概出现栈溢出的位置</p></li></ul><h4 id="JVM系列之实战内存溢出异常"><a href="#JVM系列之实战内存溢出异常" class="headerlink" title="JVM系列之实战内存溢出异常"></a>JVM系列之实战内存溢出异常</h4><h5 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h5><p>关于对象的创建，第一反应是new关键字，那么本文就主要讲解new关键字创建对象的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu =new Student(&quot;张三&quot;，&quot;18&quot;);</span><br></pre></td></tr></table></figure></p><p>就拿上面这句代码来说，虚拟机首先会去检查Student这个类有没有被加载，如果没有，首先去加载这个类到方法区，然后根据加载的Class类对象创建stu实例对象，需要注意的是，stu对象所需的内存大小在Student类加载完成后便可完全确定。内存分配完成后，虚拟机需要将分配到的内存空间的实例数据部分初始化为零值,这也就是为什么我们在编写Java代码时创建一个变量不需要初始化。紧接着，虚拟机会对对象的对象头进行必要的设置，如这个对象属于哪个类，如何找到类的元数据(Class对象),对象的锁信息，GC分代年龄等。设置完对象头信息后，调用类的构造函数。<br>其实讲实话，虚拟机创建对象的过程远不止这么简单，我这里只是把大致的脉络讲解了一下，方便大家理解。</p><h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>刚刚提到的实例数据，对象头，有些小伙伴也许有点陌生，这一小节就详细讲解一下对象的内存布局,对象创建完成后大致可以分为以下几个部分:</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充</li></ul><p><strong><em>对象头</em></strong> : 对象头中包含了对象运行时一些必要的信息，如GC分代信息，锁信息，哈希码，指向Class类元信息的指针等，其中对Javaer比较有用的是锁信息与指向Class对象的指针，关于锁信息，后期有机会讲解并发编程JUC时再扩展，关于指向Class对象的指针其实很好理解。比如上面那个Student的例子，当我们拿到stu对象时，调用Class stuClass=stu.getClass();的时候，其实就是根据这个指针去拿到了stu对象所属的Student类在方法区存放的Class类对象。虽然说的有点拗口，但这句话我反复琢磨了好几遍，应该是说清楚了。^_^</p><p><strong><em>实例数据</em></strong> :实例数据部分是对象真正存储的有效信息，就是程序代码中所定义的各种类型的字段内容。</p><p><strong><em>对齐填充</em></strong> :虚拟机规范要求对象大小必须是8字节的整数倍。对齐填充其实就是来补全对象大小的。</p><h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>谈到对象的访问，还拿上面学生的例子来说，当我们拿到stu对象时，直接调用stu.getName();时，其实就完成了对对象的访问。但这里要累赘说一下的是，stu虽然通常被认为是一个对象，其实准确来说是不准确的，stu只是一个变量，变量里存储的是指向对象的指针，(如果干过C或者C++的小伙伴应该比较清楚指针这个概念)，当我们调用stu.getName()时，虚拟机会根据指针找到堆里面的对象然后拿到实例数据name.需要注意的是，当我们调用stu.getClass()时，虚拟机会首先根据stu指针定位到堆里面的对象，然后根据对象头里面存储的指向Class类元信息的指针再次到方法区拿到Class对象，进行了两次指针寻找。具体讲解图如下:<br><img src="http://prl6c63q7.bkt.clouddn.com/b15.jpg" alt></p><h4 id="实战内存异常"><a href="#实战内存异常" class="headerlink" title="实战内存异常"></a>实战内存异常</h4><p>内存异常是我们工作当中经常会遇到问题，但如果仅仅会通过加大内存参数来解决问题显然是不够的，应该通过一定的手段定位问题，到底是因为参数问题，还是程序问题(无限创建，内存泄露)。定位问题后才能采取合适的解决方案，而不是一内存溢出就查找相关参数加大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概念</span><br><span class="line">- 内存泄露:代码中的某个对象本应该被虚拟机回收，但因为拥有GCRoot引用而没有被回收。关于GCRoot概念，下一篇文章讲解。</span><br><span class="line">- 内存溢出: 虚拟机由于堆中拥有太多不可回收对象没有回收，导致无法继续创建新对象。</span><br></pre></td></tr></table></figure><p>在分析问题之前先给大家讲一讲排查内存溢出问题的方法，内存溢出时JVM虚拟机会退出，那么我们怎么知道JVM运行时的各种信息呢，Dump机制会帮助我们，可以通过加上VM参数-XX:+HeapDumpOnOutOfMemoryError让虚拟机在出现内存溢出异常时生成dump文件，然后通过外部工具(作者使用的是VisualVM)来具体分析异常的原因。</p><p>下面从以下几个方面来配合代码实战演示内存溢出及如何定位:</p><ul><li>Java堆内存异常</li><li>Java栈内存异常</li><li>方法区内存异常</li></ul><h5 id="Java堆内存异常"><a href="#Java堆内存异常" class="headerlink" title="Java堆内存异常"></a>Java堆内存异常</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** VM Args: //这两个参数保证了堆中的可分配内存固定为20M -Xms20m -Xmx20m //文件生成的位置，作则生成在桌面的一个目录 -XX:+HeapDumpOnOutOfMemoryError //文件生成的位置，作则生成在桌面的一个目录 //文件生成的位置，作则生成在桌面的一个目录 -XX:HeapDumpPath=/Users/zdy/Desktop/dump/ */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    //创建一个内部类用于创建对象使用</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        //无限创建对象，在堆中</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run起来代码后爆出异常如下:</p><p><strong><em>java.lang.OutOfMemoryError: Java heap space</em></strong><br>Dumping heap to /Users/zdy/Desktop/dump/java_pid1099.hprof …</p><p>可以看到生成了dump文件到指定目录。并且爆出了OutOfMemoryError，还告诉了你是哪一片区域出的问题:heap space</p><p>打开VisualVM工具导入对应的heapDump文件(如何使用请读者自行查阅相关资料)，相应的说明见图:<br><img src="http://prl6c63q7.bkt.clouddn.com/b16.png" alt><br>“类标签”</p><p>切换到”实例数”标签页<br><img src="http://prl6c63q7.bkt.clouddn.com/b17.png" alt><br>“实例数标签”</p><p>分析dump文件后，我们可以知道，OOMObject这个类创建了810326个实例。所以它能不溢出吗？接下来就在代码里找这个类在哪new的。排查问题。(我们的样例代码就不用排查了，While循环太凶猛了)</p><h5 id="Java栈内存异常"><a href="#Java栈内存异常" class="headerlink" title="Java栈内存异常"></a>Java栈内存异常</h5><p>老实说，在栈中出现异常(StackOverFlowError)的概率小到和去苹果专卖店买手机，买回来后发现是Android系统的概率是一样的。因为作者确实没有在生产环境中遇到过，除了自己作死写样例代码测试。先说一下异常出现的情况，前面讲到过，方法调用的过程就是方法帧进虚拟机栈和出虚拟机栈的过程，那么有两种情况可以导致StackOverFlowError,当一个方法帧(比如需要2M内存)进入到虚拟机栈(比如还剩下1M内存)的时候，就会报出StackOverFlow.这里先说一个概念，栈深度:指目前虚拟机栈中没有出栈的方法帧。虚拟机栈容量通过参数-Xss来控制,下面通过一段代码，把栈容量人为的调小一点，然后通过递归调用触发异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * VM Args： //设置栈容量为160K，默认1M -Xss160k */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        <span class="comment">//递归调用，触发异常</span></span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:<br><strong><em>stack length:751</em></strong><br><strong><em>Exception in thread “main” java.lang.StackOverflowError</em></strong></p><p>可以看到，递归调用了751次，栈容量不够用了。<br>默认的栈容量在正常的方法调用时，栈深度可以达到1000-2000深度，所以，一般的递归是可以承受的住的。如果你的代码出现了StackOverflowError，首先检查代码，而不是改参数。</p><p>这里顺带提一下，很多人在做多线程开发时，当创建很多线程时，容易出现OOM(OutOfMemoryError),这时可以通过具体情况，减少最大堆容量，或者栈容量来解决问题，这是为什么呢。请看下面的公式:</p><p><strong><em>线程数 乘以 (最大栈容量)+最大堆值+其他内存(忽略不计或者一般不改动)=机器最大内存</em></strong></p><p>当线程数比较多时，且无法通过业务上削减线程数，那么再不换机器的情况下，你只能把最大栈容量设置小一点，或者把最大堆值设置小一点。</p><h5 id="方法区内存异常"><a href="#方法区内存异常" class="headerlink" title="方法区内存异常"></a>方法区内存异常</h5><p>写到这里时，作者本来想写一个无限创建动态代理对象的例子来演示方法区溢出，避开谈论JDK7与JDK8的内存区域变更的过渡，但细想一想，还是把这一块从始致终的说清楚。在上一篇文章中JVM系列之Java内存结构详解讲到方法区时提到，JDK7环境下方法区包括了(运行时常量池),其实这么说是不准确的。因为从JDK7开始，HotSpot团队就想到开始去”永久代”,大家首先明确一个概念，方法区和”永久代”(PermGen space)是两个概念，方法区是JVM虚拟机规范，任何虚拟机实现(J9等)都不能少这个区间，而”永久代”只是HotSpot对方法区的一个实现。为了把知识点列清楚，我还是才用列表的形式:</p><ul><li>JDK7之前(包括JDK7)拥有”永久代”(PermGen space),用来实现方法区。但在JDK7中已经逐渐在实现中把永久代中把很多东西移了出来，比如:符号引用(Symbols)转移到了native heap,运行时常量池(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap.<br>所以这就是为什么我说上一篇文章中说方法区中包含运行时常量池是不正确的，因为已经移动到了java heap;</li><li>在JDK7之前(包括7)可以通过-XX:PermSize -XX:MaxPermSize来控制永久代的大小.</li><li>JDK8正式去除”永久代”,换成Metaspace(元空间)作为JVM虚拟机规范中方法区的实现。</li><li>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但仍可以通过参数控制:-XX:MetaspaceSize与-XX:MaxMetaspaceSize来控制大小。</li></ul><p>下面作者还是通过一段代码，来不停的创建Class对象，在JDK8中可以看到metaSpace内存溢出:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 作者准备在JDK8下测试方法区，所以设置了Metaspace的大小为固定的8M -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//无限创建动态代理，生成Class对象</span></span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK8的环境下将报出异常:<br><strong><em>Exception in thread “main” java.lang.OutOfMemoryError: Metaspace</em></strong><br>这是因为在调用CGLib的创建代理时会生成动态代理类，即Class对象到Metaspace,所以While一下就出异常了。<br><strong><em>提醒一下:虽然我们日常叫”堆Dump”,但是dump技术不仅仅是对于”堆”区域才有效，而是针对OOM的，也就是说不管什么区域，凡是能够报出OOM错误的，都可以使用dump技术生成dump文件来分析。</em></strong></p><p>在经常动态生成大量Class的应用中，需要特别注意类的回收状况，这类场景除了例子中的CGLib技术，常见的还有，大量JSP，反射，OSGI等。需要特别注意，当出现此类异常，应该知道是哪里出了问题，然后看是调整参数，还是在代码层面优化。</p><h5 id="附加-直接内存异常"><a href="#附加-直接内存异常" class="headerlink" title="附加-直接内存异常"></a>附加-直接内存异常</h5><p>直接内存异常非常少见，而且机制很特殊，因为直接内存不是直接向操作系统分配内存，而且通过计算得到的内存不够而手动抛出异常，所以当你发现你的dump文件很小，而且没有明显异常，只是告诉你OOM，你就可以考虑下你代码里面是不是直接或者间接使用了NIO而导致直接内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：https://my.oschina.net/u/2401092/blog/1621850</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内存溢出-amp-amp-栈溢出&quot;&gt;&lt;a href=&quot;#内存溢出-amp-amp-栈溢出&quot; class=&quot;headerlink&quot; title=&quot;内存溢出&amp;amp;&amp;amp;栈溢出&quot;&gt;&lt;/a&gt;内存溢出&amp;amp;&amp;amp;栈溢出&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p5.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;内存溢出&quot;&gt;&lt;a href=&quot;#内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存溢出&quot;&gt;&lt;/a&gt;内存溢出&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之线程安全性、安全发布对象</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/并发编程之线程安全性、安全发布对象/</id>
    <published>2019-05-23T15:04:38.000Z</published>
    <updated>2019-05-24T02:41:28.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><img src="http://prl6c63q7.bkt.clouddn.com/p6.jpg" alt><br>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。<br><a id="more"></a><br>线程安全性主要体现：</p><ol><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般是杂乱无序</li></ol><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><h5 id="Atomic包"><a href="#Atomic包" class="headerlink" title="Atomic包"></a>Atomic包</h5><p>位于java.util.concurrent.atomic<br>AtomicXXX : CAS、Unsafe.compareAndSwapXXX<br>  CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p><h6 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class CountExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line">    //从int类型换成了AtomicInteger</span><br><span class="line">    public static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        //调用了AtomicInteger方法</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        // count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全？源码分析<br>AtomicInteger.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line">// setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe(); //通过反射获得</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">       (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">   &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">        //this 代表当前AtomicInteger对象</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Unsafe.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//本地方法，java底层方法</span><br><span class="line">/**</span><br><span class="line"> * @param var1 对象</span><br><span class="line"> * @param var2 偏移量</span><br><span class="line"> * @param var3 期望值</span><br><span class="line"> * @param var5 修改值</span><br><span class="line"> */</span><br><span class="line"> public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param var1 当前对象</span><br><span class="line"> * @param var2 当前值</span><br><span class="line"> * @param var3 增量</span><br><span class="line"> */</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">        int var5; //底层值</span><br><span class="line">        do &#123;</span><br><span class="line">            var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        // CAS核心</span><br><span class="line">        //当前值与底层值相同，则更新成var5 + var4</span><br><span class="line">        //不一样则不停的循环，直到值相同</span><br><span class="line">        return var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AtomicInLong 与 LongAdder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample2 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static AtomicLong count = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        // count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample3 &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static LongAdder count = new LongAdder();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        count.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInLong 与 LongAdder 比较<br>就像我们所知道的那样,AtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。如果竞争不激烈，修改成功几率很高，否则失败概率很高，在失败几率很高的情况下，这些原子操作就会进行多次的循环操作尝试，因此性能会受到影响。</p><p>对于普通类型的Long和Doubble变量，JVM允许将64位的读操作或写操作拆成两个三十二位的操作。</p><p>LongAdder的核心是将热点数据分离，比如说它可以将AtomicLong内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法，映射到其中一个数字进行计数，最终的计数结果则会这个数据的求和累加，其中热点数据value会被分离成多个cell，每个cell独自维护内部的值，当前对象实际值为所有cell累计合成，这样的话，热点就进行了有效的分离，并提高了并行度。</p><p>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</p><p>​缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。</p><p>​实际使用中，在处理高并发时，可以优先使用LongAdder，而不是继续使用AtomicLong，当然，在线程竞争很低的情况下，使用AtomicLong更简单更实际一些，并且效率会高些。其他情况下，比如序列号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择，而不是LongAdder</p><h6 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The AtomicReference class provides reference objects that may be read and written atomically, so when multiple threads try to reach them at the same time, only one will be able to do so</span><br></pre></td></tr></table></figure><h5 id="原子性引用"><a href="#原子性引用" class="headerlink" title="原子性引用"></a>原子性引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class AtomicExample4 &#123;</span><br><span class="line"></span><br><span class="line">    private static AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        count.compareAndSet(0, 2); // 2</span><br><span class="line">        count.compareAndSet(0, 1); // no</span><br><span class="line">        count.compareAndSet(1, 3); // no</span><br><span class="line">        count.compareAndSet(2, 4); // 4</span><br><span class="line">        count.compareAndSet(3, 5); // no</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例比较简单，我有个疑问？假如我们引用的是一个自定义的对象，并且对象里面有属性值，然后，修改对象中的属性值也是原子性的吗？还是只是对对象的引用是原子性操作。<br>带着上面的疑问，进行源码分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -1848883965231344442L;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile V value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new AtomicReference with the given initial value.</span><br><span class="line">     *</span><br><span class="line">     * @param initialValue the initial value</span><br><span class="line">     */</span><br><span class="line">    public AtomicReference(V initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new AtomicReference with null initial value.</span><br><span class="line">     */</span><br><span class="line">    public AtomicReference() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不需要安全防护</span><br><span class="line">     */</span><br><span class="line">    public final V get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设值值不需要进行对象安全防护</span><br><span class="line">     */</span><br><span class="line">    public final void set(V newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 很明显调用的是csa操作</span><br><span class="line">     * 比较对象是否相同，进行设值</span><br><span class="line">     * 设值成功返回true，否则返回false</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置新的值并且返回旧的值</span><br><span class="line">     * 原子操作</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public final V getAndSet(V newValue) &#123;</span><br><span class="line">        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过源码分析，可以得出</p><ul><li>AtomicReference 所提供的某些方法可以进行原子性操作，如compareAndSet、getAndSet，这仅仅是对引用进行原子性操作</li><li>AtomicReference  不能保证对象中若存在属性值修改是线程安全的，如假设引用对象是person，修改person中name和age，多个线程同时从引用中获得对象，并进行修改，会出现线程不安全情况。下面我们通过代码来验证一下这条结论。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe</span><br><span class="line">public class AtomicReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 1000;</span><br><span class="line"></span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 500;</span><br><span class="line"></span><br><span class="line">    public static Person person = new Person(0,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static AtomicReference&lt;Person&gt; personAtomicReference = new AtomicReference(person);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            final int result = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    modify(result);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;name:&#123;&#125;,age:&#123;&#125;&quot;,personAtomicReference.get().getName(), personAtomicReference.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果线程安全的话，age的值和name的值是一致的</span><br><span class="line">    //如果线程不安全的话，age的值和name是不一样的。</span><br><span class="line">    private static void modify(int i) &#123;</span><br><span class="line">        personAtomicReference.get().setAge(personAtomicReference.get().getAge() + i);</span><br><span class="line">        personAtomicReference.get().setName(personAtomicReference.get().getName() + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在低并发的情况下，输出的结果是正确的，但是在高并发的情况下结果差距就很大了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:09:52.473 [main] INFO com.mmall.concurrency.example.atomic.AtomicReferenceTest - name:496592,age:496922</span><br></pre></td></tr></table></figure></p><h6 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h6><p>atomic包中提供AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater，原子性的更新某一个类实例的指定的某一个字段</p><ul><li>AtomicIntegerFieldUpdater<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AtomicIntegerFieldUpdater 原子性的更新某一个类的实例的指定的某一个字段</span></span><br><span class="line">    <span class="comment">//并且该字段由volatile进行修饰同时不能被static修饰</span></span><br><span class="line">    <span class="comment">//有些网上说而且不能被private修饰？下文将进行验证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:48:27.815 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update success 1, 120</span><br><span class="line">18:48:27.825 [main] INFO com.mmall.concurrency.example.atomic.AtomicExample5 - update failed, 120</span><br></pre></td></tr></table></figure></p><p>源码分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tclass 持有某字段的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName 字段名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String fieldName)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicIntegerFieldUpdaterImpl&lt;U&gt;</span><br><span class="line">            (tclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子性设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(T obj, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get(obj);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(obj, prev, newValue));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterImpl</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">AtomicIntegerFieldUpdater</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; tclass;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; cclass;</span><br><span class="line"></span><br><span class="line">        AtomicIntegerFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line">                                      <span class="keyword">final</span> String fieldName,</span><br><span class="line">                                      <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line">            <span class="keyword">final</span> Field field;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">                            <span class="comment">//字段不存在会抛异常</span></span><br><span class="line">                            <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                 <span class="comment">//检查访问级别</span></span><br><span class="line">                modifiers = field.getModifiers();</span><br><span class="line">                sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">                    caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line">                ClassLoader cl = tclass.getClassLoader();</span><br><span class="line">                ClassLoader ccl = caller.getClassLoader();</span><br><span class="line">                <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line">                    ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">                  sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; fieldt = field.getType();</span><br><span class="line">            <span class="comment">//必须是int</span></span><br><span class="line">            <span class="keyword">if</span> (fieldt != <span class="keyword">int</span>.class)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be integer type"</span>);</span><br><span class="line">            <span class="comment">//必须用volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                           caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line">            <span class="comment">//用Unsafe里的那一坨方法去原子更新</span></span><br><span class="line">            offset = unsafe.objectFieldOffset(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码分析中，可以看出没有要求不能被private修饰</p><h6 id="AtomicStampReference"><a href="#AtomicStampReference" class="headerlink" title="AtomicStampReference"></a>AtomicStampReference</h6><p> 此类是要核心解决CAS的ABA问题<br> ​   ABA问题：指CAS操作的时候，线程将某个变量值由A修改为B，但是又改回了A，其他线程发现A并未改变，于是CAS将进行值交换操作，实际上该值已经被改变过，这与CAS的核心思想是不符合的</p><p> ​   解决思路：每次变量更新的时候，把变量的版本号进行更新，如果某变量被某个线程修改过，那么版本号一定会递增更新，从而解决ABA问题</p><p> ​   J.U.C 提供了两个类解决ABA问题，一个是AtomicStampReference ，另一个是 AtomicMarkableReference</p><h6 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h6><p> AtomicLong是作用是对长整形进行原子操作。而AtomicLongArray的作用则是对”长整形数组”进行原子操作,根据索引，对数据中的指定位置的数据进行院子性的更新</p><h6 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h6> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappened = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"isHappened:&#123;&#125;"</span>, isHappened.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 演示如何让一段代码中的某个逻辑在高并发场景下只执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原子性操作，保证从false 到 true 只会执行一次</span></span><br><span class="line">        <span class="keyword">if</span> (isHappened.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"execute"</span>); <span class="comment">//只会执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h6><p>JAVA中能保证同一时刻，只有一个线程来进行对其进行操作的，除了atomic包中所提供的类之外，还有jdk提供的锁，JAVA主要提供以下锁：</p><ol><li><p>synchronized : 关键字，并且依赖与JVM，作用对象的作用范围内都是同一时刻只能有一个线程对其操作的</p></li><li><p>Lock : 接口类，依赖特殊的CPU指定，使用代码实现，常用子类ReentrantLock</p></li></ol><h6 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h6><ul><li>修饰代码块：大括号括起来的代码，也称同步代码块，作用与调用的对象</li><li>修饰方法：整个方法，也称同步方法，作用与调用的对象</li><li>修饰静态方法：整个静态方法，作用于类的所有对象</li><li>修饰类：括号括起来的部分，作用与类的所有对象</li></ul><h6 id="同步代码块与同步方法演示与解析"><a href="#同步代码块与同步方法演示与解析" class="headerlink" title="同步代码块与同步方法演示与解析"></a>同步代码块与同步方法演示与解析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块 作用于调用的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法 同步方法 作用于调用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test2(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//example1.test2(1)</span></span><br><span class="line">            example2.test2(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若线程池中开启两个线程：</p><p>使用同步方法进行验证：</p><p>​ 若两个线程中都使用同一个对象进行操作，那么他们是同步的,输出的结果都是先执行test2-1 0-9的输出后执行test2-2 0-9的输出或先执行test2-2 0-9的输出后执行test2-1 0-9的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(1);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(2)</span><br><span class="line">    //example2.test2(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若两个线程中不使用同一个对象进行操作，那么他们输出即为交叉执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    example1.test2(1);</span><br><span class="line">&#125;);</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    //example1.test2(2)</span><br><span class="line">    example2.test2(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意：如果某个类为父类，并且存在同步方法，子类在继承这个类后，如果子类调用该父类的同步方法后，该方法是没有synchronized关键字的，原因是synchronized不属于方法声明的一部分</p><p>修饰静态方法与修饰类演示与解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="comment">//作用于类的所有对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample2.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test1(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//example1.test2(1);</span></span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example2.test1(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//example2.test2(2);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面类的执行结果，同一个类的不同对象执行同步修饰的方法，执行的顺序是同步的</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ul><li>synchronized ：不可中断锁，适合竞争不激烈，可读性较好</li><li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li><li>Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值</li></ul><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>一个线程对主内存的修改可以及时的被其他线程观察到。<br>导致共享变量在线程间不可见的原因：</p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>对于可见性，JVM提供了 synchronized 和 volatile</p><h6 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h6><p> JMM关于synchronized的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li><p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）</p><h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>通过加入内存屏障和禁止重排序优化来实现</p></li><li><p>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存中<br><img src="http://prl6c63q7.bkt.clouddn.com/b13.png" alt></p></li><li><p>对volatile变量读操作是，会在读操作前加入一条load屏障指令，从主内存中读取共享变量<br><img src="http://prl6c63q7.bkt.clouddn.com/b14.png" alt></p><p>通过上面两点，任何时候，不同的线程总能看到该变量的最新值。所有的指令操作都是CPU级别的</p><h6 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果是线程不安全的。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过例子可以得知，即使通过volatile修饰变量，但依然无法保证线程安全</p><p>原因分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void add() &#123;</span><br><span class="line">    count++; //分3步</span><br><span class="line">    //1.取出当前count值</span><br><span class="line">    //2.count + 1</span><br><span class="line">    //3.count 重新写回主存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设同时有两个线程进行操作，两个线程同时执行到第一步（从内存中读取最新值）得到一样的最新的结果，然后进入第二步（+1操作）并进行第三步（从新写回主存）。尽管第一步获取的值是一样的，但是同时将+1后的操作写回主存，这样就会丢掉某个+1的操作，这样就会出现线程不安全问题<br>结论：</p><ul><li>volatile进行加操作线程不安全的，不适合计数场景</li><li>volatile关键字不具有原子性</li></ul><p>使用场景<br>  使用volatile必须具备两个条件</p><ul><li>对变量的写操作，不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式子中</li></ul><p>因此volatile适合作为状态的标记量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited = false;</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">context = loadContext();</span><br><span class="line">inited = true;</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">while(!inited)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>JAVA内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p><p>volatile、synchronized、Lock：通过 volatile、synchronized、Lock 保证一定的有序性。显然，synchronized、Lock 保证每一个时刻只有一个线程可以执行被同步的代码，相当于让线程顺序执行同步代码，从而保证有序性。另外，JMM具备一些先天的有序性，即不需要额外的手段，就能保证有序性，即 Happens-before 原则，如果两个操作的执行次序，没有办法通过 Happens-before   原则推到出来，虚拟机进行随意的重排序，那么就不能保证有序行。</p><h6 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h6><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li></ul><p>(个人理解：一段程序代码的执行，在单个线程中看起来是有序的，程序看起来的执行是按照代码的顺序执行的，因为虚拟机可能会对指令进行重排序，虽然进行了重排序，但是最终结果是与程序顺序执行的结果是一致的，只会对不存在数据依赖的指令进行重排序，因此在单个线程中是有序执行的。这条规则是保证程序在单线程中执行结果的正确性，但无法保证多线程执行结果的正确性)</p><ul><li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</p></li><li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</p></li></ul><h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><p>安全发布对象的四种方法：</p><ol><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>  Spring 框架中，Spring管理的类都是单例模式。如何保证一个实例只被初始化一次，且线程安全？通过不同单例的写法，具体描述安全发布对象的四种方法：</p><h5 id="普通单例模式"><a href="#普通单例模式" class="headerlink" title="普通单例模式"></a>普通单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可能这里会存在很多的操作</span></span><br><span class="line">        <span class="comment">//如资源加载、运算等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="comment">// 单线毫无问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程环境下存在线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 缺点：1.若构造方法中存在过多的处理、会导加载缓慢，从而引起性能问题</span></span><br><span class="line"><span class="comment"> *       2.只进行加载，并无实际调用，导致资源浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双重检测机制"><a href="#双重检测机制" class="headerlink" title="双重检测机制"></a>双重检测机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式 -》 双重同步锁单例模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        // B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4(); <span class="comment">// A - 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样的双重检测机制是线程不安全的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程环境下</span></span><br><span class="line">    <span class="comment">// JVM和cpu优化，发生了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 3、instance = memory 设置instance指向刚分配的内存</span></span><br><span class="line">    <span class="comment">// 2、ctorInstance() 初始化对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设存在线程A、B同时进入双重检测机制</span></span><br><span class="line">    <span class="comment">//当线程A执行到 instance = new SingletonExample4(); // A - 执行到指令的第三步进行内存分配，但是未初始化对象</span></span><br><span class="line">    <span class="comment">//B执行到 if (instance == null) &#123; // 双重检测机制     //b发现instance不为空，直接返回对象，实上对象初始化并未开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态域初始化"><a href="#静态域初始化" class="headerlink" title="静态域初始化"></a>静态域初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 静态域与静态代码块是顺序执行的，若将1 2 处位置进行交换则会出现空指针异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最安全的枚举模式"><a href="#最安全的枚举模式" class="headerlink" title="最安全的枚举模式"></a>最安全的枚举模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举模式：最安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全策略"><a href="#线程安全策略" class="headerlink" title="线程安全策略"></a>线程安全策略</h3><p>创建后状态不能被修改的对象叫作不可变对象。不可变对象天生就是线程安全的。它们的常量（变量）是在构造函数中创建的，既然它们的状态无法被修改，那么这些常量永远不会被改变——不可变对象永远是线程安全的。<br>不可变对象需要满足的条件</p><ul><li>对象创建以后其状态就不能修改</li><li>对象所有域都是final类型</li><li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li></ul><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final关键字：类、方法、变量</p><ul><li>修饰类：不能被继承，final类中的成员属性可以根据需要设置为final，但final类中所有的成员方法都被隐式指定为final方法。一般不建议将类设置为final类型。可以参考String类。</li><li>修饰方法：1）锁定方法不被继承类修改；2）效率</li><li>修饰变量：1）基本数据类型变量，初始化后便不能进行修改；2）引用类型变量，初始化之后不能再指向别的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="comment">//引用类型不允许引用指向改变，但是对象值还是可以进行修改的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 2;              //编译时报错</span></span><br><span class="line"><span class="comment">//        b = "3";            //编译时报错</span></span><br><span class="line"><span class="comment">//        map = Maps.newHashMap();   //编译时报错</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);       <span class="comment">//容易引发线程安全问题</span></span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以修饰参数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p>java提供Collections工具类，在类中提供了多种不允许修改的方法</p><p>​ Collections.unmodifiableXXX：Collection、List、Set、Map…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample2 &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(1, 2);</span><br><span class="line">        map.put(3, 4);</span><br><span class="line">        map.put(5, 6);</span><br><span class="line">        //处理过后的map是不可以再进行修改的</span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //允许操作，但是操作会报错，扔出异常</span><br><span class="line">        map.put(1, 3);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableMap&lt;&gt;(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p>​ 谷歌的Guava提供类似Java中的Collections</p><p>​ ImmutableXXX：Collection、List、Set、Map…</p><p><strong><em>pom.xml</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class ImmutableExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);</span><br><span class="line">    </span><br><span class="line">    private final static List&lt;Integer&gt; lists = ImmutableList.of(1, 2, 3);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);</span><br><span class="line"></span><br><span class="line">    private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(1, 2).put(3, 4).put(5, 6).build();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(map2.get(3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源：https://www.jianshu.com/p/895950290179</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p6.jpg&quot; alt&gt;&lt;br&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CPU缓存一致性协议MESI</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEMESI/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/CPU缓存一致性协议MESI/</id>
    <published>2019-05-23T03:40:52.000Z</published>
    <updated>2019-05-23T09:28:00.562Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://prl6c63q7.bkt.clouddn.com/p3.jpg" alt="输入图片说明"></p><h3 id="CPU高速缓存（Cache-Memory）"><a href="#CPU高速缓存（Cache-Memory）" class="headerlink" title="CPU高速缓存（Cache Memory）"></a>CPU高速缓存（Cache Memory）</h3><h4 id="CPU为何要有高速缓存"><a href="#CPU为何要有高速缓存" class="headerlink" title="CPU为何要有高速缓存"></a>CPU为何要有高速缓存</h4><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p><a id="more"></a><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</span><br></pre></td></tr></table></figure><p>比如循环、递归、方法的反复调用等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</span><br></pre></td></tr></table></figure><p>比如顺序执行的代码、连续创建的两个对象、数组等。</p><h4 id="带有高速缓存的CPU执行计算的流程"><a href="#带有高速缓存的CPU执行计算的流程" class="headerlink" title="带有高速缓存的CPU执行计算的流程"></a>带有高速缓存的CPU执行计算的流程</h4><ol><li><p>程序以及数据被加载到主内存</p></li><li><p>指令和数据被加载到CPU的高速缓存</p></li><li><p>CPU执行指令，把结果写到高速缓存</p></li><li><p>高速缓存中的数据写回主内存</p></li></ol><p><img src="http://prl6c63q7.bkt.clouddn.com/b5.png" alt></p><h4 id="目前流行的多级缓存结构"><a href="#目前流行的多级缓存结构" class="headerlink" title="目前流行的多级缓存结构"></a>目前流行的多级缓存结构</h4><p>由于CPU的运算速度超越了1级缓存的数据I\O能力，CPU厂商又引入了多级的缓存结构。</p><p>多级缓存结构<br><img src="http://prl6c63q7.bkt.clouddn.com/b6.png" alt></p><h3 id="多核CPU多级缓存一致性协议MESI"><a href="#多核CPU多级缓存一致性协议MESI" class="headerlink" title="多核CPU多级缓存一致性协议MESI"></a>多核CPU多级缓存一致性协议MESI</h3><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。</p><h4 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a>MESI协议缓存状态</h4><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存行（Cache line）:缓存存储数据的单元。</span><br></pre></td></tr></table></figure><p><img src="http://prl6c63q7.bkt.clouddn.com/b1.png" alt="输入图片说明"></p><p>注意：<br> <strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。</strong><br>如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p><p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p><h4 id="MESI状态转换"><a href="#MESI状态转换" class="headerlink" title="MESI状态转换"></a>MESI状态转换</h4><p><img src="http://prl6c63q7.bkt.clouddn.com/b7.png" alt="输入图片说明"></p><p>理解该图的前置说明：<br>1.触发事件</p><table><br><thead><br><tr class="header"><br><th style="text-align: left;">触发事件</th><br><th style="text-align: left;">描述</th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: left;">本地读取（Local read）</td><br><td style="text-align: left;">本地cache读取本地cache数据</td><br></tr><br><tr class="even"><br><td style="text-align: left;">本地写入（Local write）</td><br><td style="text-align: left;">本地cache写入本地cache数据</td><br></tr><br><tr class="odd"><br><td style="text-align: left;">远端读取（Remote read）</td><br><td style="text-align: left;">其他cache读取本地cache数据</td><br></tr><br><tr class="even"><br><td style="text-align: left;">远端写入（Remote write）</td><br><td style="text-align: left;">其他cache写入本地cache数据</td><br></tr><br></tbody><br></table><p>2.cache分类：<br>前提：所有的cache共同缓存了主内存中的某一条数据。</p><p>本地cache:指当前cpu的cache。<br>触发cache:触发读写事件的cache。<br>其他cache:指既除了以上两种之外的cache。<br>注意：本地的事件触发 本地cache和触发cache为相同。</p><p>上图的切换解释：</p><table><br><thead><br><tr class="header"><br><th style="text-align: center;">状态</th><br><th style="text-align: center;">触发本地读取</th><br><th style="text-align: center;">触发本地写入</th><br><th style="text-align: center;">触发远端读取</th><br><th style="text-align: center;">触发远端写入</th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: center;"><strong>M状态（修改）</strong></td><br><td style="text-align: center;">本地cache:M <br>触发cache:M<br>其他cache:I</td><br><td style="text-align: center;">本地cache:M <br>触发cache:M<br>其他cache:I</td><br><td style="text-align: center;">本地cache:M→E→S<br>触发cache:I→S<br>其他cache:I→S<br>同步主内存后修改为E独享,同步触发、其他cache后本地、触发、其他cache修改为S共享</td><br><td style="text-align: center;">本地cache:M→E→S→I<br>触发cache:I→S→E→M<br>其他cache:I→S→I<br>同步和读取一样,同步完成后触发cache改为M，本地、其他cache改为I</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>E状态（独享）</strong></td><br><td style="text-align: center;">本地cache:E<br>触发cache:E<br>其他cache:I</td><br><td style="text-align: center;">本地cache:E→M<br>触发cache:E→M<br>其他cache:I<br>本地cache变更为M,其他cache状态应当是I（无效）</td><br><td style="text-align: center;">本地cache:E→S<br>触发cache:I→S<br>其他cache:I→S<br>当其他cache要读取该数据时，其他、触发、本地cache都被设置为S(共享)</td><br><td style="text-align: center;">本地cache:E→S→I<br>触发cache:I→S→E→M<br>其他cache:I→S→I<br>当触发cache修改本地cache独享数据时时，将本地、触发、其他cache修改为S共享.然后触发cache修改为独享，其他、本地cache修改为I（无效），触发cache再修改为M</td><br></tr><br><tr class="odd"><br><td style="text-align: center;"><strong>S状态(共享)</strong></td><br><td style="text-align: center;">本地cache:S<br>触发cache:S<br>其他cache:S</td><br><td style="text-align: center;">本地cache:S→E→M<br>触发cache:S→E→M<br>其他cache:S→I <br>当本地cache修改时，将本地cache修改为E,其他cache修改为I,然后再将本地cache为M状态</td><br><td style="text-align: center;">本地cache:S<br>触发cache:S<br>其他cache:S</td><br><td style="text-align: center;">本地cache:S→I<br>触发cache：S→E→M<br>其他cache:S→I<br>当触发cache要修改本地共享数据时，触发cache修改为E（独享）,本地、其他cache修改为I（无效）,触发cache再次修改为M(修改)</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>I状态（无效）</strong></td><br><td style="text-align: center;">本地cache:I→S或者I→E<br>触发cache:I→S或者I →E<br>其他cache:E、M、I→S、I<br>本地、触发cache将从I无效修改为S共享或者E独享，其他cache将从E、M、I 变为S或者I</td><br><td style="text-align: center;">本地cache:I→S→E→M<br>触发cache:I→S→E→M<br>其他cache:M、E、S→S→I<br></td><br><td style="text-align: center;">既然是本cache是I，其他cache操作与它无关</td><br><td style="text-align: center;">既然是本cache是I，其他cache操作与它无关</td><br></tr><br></tbody><br></table><p>下图示意了，当一个cache line的调整的状态的时候，另外一个cache line 需要调整的状态。</p><table><br><thead><br><tr class="header"><br><th style="text-align: center;"></th><br><th style="text-align: center;">M</th><br><th style="text-align: center;">E</th><br><th style="text-align: center;">S</th><br><th style="text-align: center;"><strong>I</strong></th><br></tr><br></thead><br><tbody><br><tr class="odd"><br><td style="text-align: center;"><strong>M</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>E</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="odd"><br><td style="text-align: center;"><strong>S</strong></td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">×</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br></tr><br><tr class="even"><br><td style="text-align: center;"><strong>I</strong></td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br><td style="text-align: center;">√</td><br></tr><br></tbody><br></table><p>举个栗子来说：</p><p>假设cache 1 中有一个变量x = 0的cache line 处于S状态(共享)。<br>那么其他拥有x变量的cache 2、cache 3等x的cache line调整为S状态（共享）或者调整为 I 状态（无效）。</p><h4 id="多核缓存协同操作"><a href="#多核缓存协同操作" class="headerlink" title="多核缓存协同操作"></a>多核缓存协同操作</h4><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0。</p><p><img src="http://prl6c63q7.bkt.clouddn.com/b8.png" alt></p><h5 id="单核读取"><a href="#单核读取" class="headerlink" title="单核读取"></a>单核读取</h5><p>那么执行流程是：<br>CPU A发出了一条指令，从主内存中读取x。<br>从主内存通过bus读取到缓存中（远端读取Remote read）,这是该Cache line修改为E状态（独享）.</p><p><img src="http://prl6c63q7.bkt.clouddn.com/b9.png" alt></p><h5 id="双核读取"><a href="#双核读取" class="headerlink" title="双核读取"></a>双核读取</h5><p>那么执行流程是：<br>CPU A发出了一条指令，从主内存中读取x。<br>CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态。<br>CPU B发出了一条指令，从主内存中读取x。<br>CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在chche a和cache b中都被设置为S状态(共享)。</p><p><img src="http://prl6c63q7.bkt.clouddn.com/b10.png" alt></p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><p>那么执行流程是：<br>CPU A 计算完成后发指令需要修改x.<br>CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效)<br>CPU A 对x进行赋值。</p><p><img src="http://prl6c63q7.bkt.clouddn.com/b11.png" alt></p><h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>那么执行流程是：</p><p>CPU B 发出了要读取x的指令。<br>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）<br>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。</p><p><img src="http://prl6c63q7.bkt.clouddn.com/b12.png" alt="输入图片说明"></p><h3 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a>MESI优化和他们引入的问题</h3><p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p><h4 id="CPU切换状态阻塞解决-存储缓存（Store-Bufferes）"><a href="#CPU切换状态阻塞解决-存储缓存（Store-Bufferes）" class="headerlink" title="CPU切换状态阻塞解决-存储缓存（Store Bufferes）"></a>CPU切换状态阻塞解决-存储缓存（Store Bufferes）</h4><p>比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。</p><h5 id="Store-Bufferes"><a href="#Store-Bufferes" class="headerlink" title="Store Bufferes"></a>Store Bufferes</h5><p>为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。<br>这么做有两个风险</p><p>Store Bufferes的风险<br>第一、就是处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。<br>第二、保存什么时候会完成，这个并没有任何保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">value = 3；</span><br><span class="line"></span><br><span class="line">void exeToCPUA()&#123;</span><br><span class="line">  value = 10;</span><br><span class="line">  isFinsh = true;</span><br><span class="line">&#125;</span><br><span class="line">void exeToCPUB()&#123;</span><br><span class="line">  if(isFinsh)&#123;</span><br><span class="line">    //value一定等于10？！</span><br><span class="line">    assert value == 10;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试想一下开始执行时，CPU A保存着finished在E(独享)状态，而value并没有保存在它的缓存中。（例如，Invalid）。在这种情况下，value会比finished更迟地抛弃存储缓存。完全有可能CPU B读取finished的值为true，而value的值不等于10。<br> <strong>即isFinsh的赋值在value赋值之前。</strong> </p><p>这种在可识别的行为中发生的变化称为重排序（reordings）。注意，这不意味着你的指令的位置被恶意（或者好意）地更改。</p><p>它只是意味着其他的CPU会读到跟程序中写入的顺序不一样的结果。</p><p>顺便提一下NIO的设计和Store Bufferes的设计是非常相像的。</p><h4 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a>硬件内存模型</h4><p>执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。它们的约定如下：</p><ul><li>对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li><li>Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行。</li><li>处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。</li></ul><p>即便是这样处理器已然不知道什么时候优化是允许的，而什么时候并不允许。<br>干脆处理器将这个任务丢给了写代码的人。这就是内存屏障（Memory Barriers）。</p><p><code>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void executedOnCpu0() &#123;</span><br><span class="line">    value = 10;</span><br><span class="line">    //在更新数据之前必须将所有存储缓存（store buffer）中的指令执行完毕。</span><br><span class="line">    storeMemoryBarrier();</span><br><span class="line">    finished = true;</span><br><span class="line">&#125;</span><br><span class="line">void executedOnCpu1() &#123;</span><br><span class="line">    while(!finished);</span><br><span class="line">    //在读取之前将所有失效队列中关于该数据的指令执行完毕。</span><br><span class="line">    loadMemoryBarrier();</span><br><span class="line">    assert value == 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在确实安全了。完美无暇！</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>然而，对于程序员来说简直是一个灾难。不想和平台耦合我们要跨平台。Write One,Run Everywhere!<br>幸好java解决了这个问题，至于如何解决的请关注JMM(JavaMemoryMode)与物理内存相爱相杀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来源： https://www.cnblogs.com/yanlong300/p/8986041.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p3.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;CPU高速缓存（Cache-Memory）&quot;&gt;&lt;a href=&quot;#CPU高速缓存（Cache-Memory）&quot; class=&quot;headerlink&quot; title=&quot;CPU高速缓存（Cache Memory）&quot;&gt;&lt;/a&gt;CPU高速缓存（Cache Memory）&lt;/h3&gt;&lt;h4 id=&quot;CPU为何要有高速缓存&quot;&gt;&lt;a href=&quot;#CPU为何要有高速缓存&quot; class=&quot;headerlink&quot; title=&quot;CPU为何要有高速缓存&quot;&gt;&lt;/a&gt;CPU为何要有高速缓存&lt;/h4&gt;&lt;p&gt;CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/内存屏障/</id>
    <published>2019-05-23T02:29:38.000Z</published>
    <updated>2019-05-23T02:42:56.343Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://prl6c63q7.bkt.clouddn.com/p2.jpg" alt="输入图片说明"></p><h4 id="为什么会有内存屏障"><a href="#为什么会有内存屏障" class="headerlink" title="为什么会有内存屏障"></a>为什么会有内存屏障</h4><ul><li>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。</li><li>用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。<a id="more"></a><h4 id="内存屏障是什么"><a href="#内存屏障是什么" class="headerlink" title="内存屏障是什么"></a>内存屏障是什么</h4></li><li>硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。</li><li><p>内存屏障有两个作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阻止屏障两侧的指令重排序；</span><br><span class="line">强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</span><br></pre></td></tr></table></figure></li><li><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p></li><li>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</li></ul><h4 id="java内存屏障"><a href="#java内存屏障" class="headerlink" title="java内存屏障"></a>java内存屏障</h4><ul><li>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</li><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 <strong><em>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</em></strong></li></ul><h4 id="volatile语义中的内存屏障"><a href="#volatile语义中的内存屏障" class="headerlink" title="volatile语义中的内存屏障"></a>volatile语义中的内存屏障</h4><ul><li><p>volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是列表文本在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</span><br><span class="line">在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</span><br></pre></td></tr></table></figure></li><li><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p></li></ul><h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><ul><li><p>对于final域，编译器和CPU会遵循两个排序规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</span><br><span class="line">初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</span><br></pre></td></tr></table></figure></li><li><p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p></li><li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。</li><li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</li><li>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://www.jianshu.com/p/2ab5e3d7e510</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p2.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么会有内存屏障&quot;&gt;&lt;a href=&quot;#为什么会有内存屏障&quot; class=&quot;headerlink&quot; title=&quot;为什么会有内存屏障&quot;&gt;&lt;/a&gt;为什么会有内存屏障&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。&lt;/li&gt;
&lt;li&gt;用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>LongAdder解析</title>
    <link href="https://www.zengmanhua.cn/2019/05/23/LongAdder%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.zengmanhua.cn/2019/05/23/LongAdder解析/</id>
    <published>2019-05-23T00:14:41.000Z</published>
    <updated>2019-05-23T00:21:34.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LongAdder解析"><a href="#LongAdder解析" class="headerlink" title="LongAdder解析"></a>LongAdder解析</h3><p><img src="http://prl6c63q7.bkt.clouddn.com/p1.jpg" alt="输入图片说明"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘要： 对`LongAdder`的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于`AtomicLong`来说，更加适合写多读少的并发情景。今天，我们就研究一下`LongAdder`的原理，探究一下它如此高效的原因。</span><br></pre></td></tr></table></figure><a id="more"></a><p>对LongAdder的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于AtomicLong来说，更加适合写多读少的并发情景。今天，我们就研究一下LongAdder的原理，探究一下它如此高效的原因。</p><h4 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java有很多并发控制机制，比如说以AQS为基础的锁或者以CAS为原理的自旋锁。不了解AQS的朋友可以阅读我之前的AQS源码解析文章。一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</span><br><span class="line"></span><br><span class="line"> 所以，如果你有一个Long类型的值会被多线程修改，那么使用CAS进行并发控制比较好，但是如果你是需要锁住一些资源，然后进行数据库操作，那么还是使用阻塞锁比较好。</span><br><span class="line"></span><br><span class="line"> 第一种情况下，我们一般都使用AtomicLong。AtomicLong是通过无限循环不停的采取CAS的方法去设置内部的value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。</span><br><span class="line"></span><br><span class="line"> 而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”。</span><br><span class="line"></span><br><span class="line"> 我们知道LongAdder的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</span><br></pre></td></tr></table></figure><h4 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a>LongAdder的成员变量</h4><p>LongAdder是Striped64 的子类，其有三个比较重要的成员函数，在之后的函数分析中需要使用到，这里先说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CPU的数量</span><br><span class="line">static final int NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">// Cell对象的数组，长度一般是2的指数</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 基础value值，当并发较低时，只累加该值</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 创建或者扩容Cells数组时使用的自旋锁变量</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure><p>cells是LongAdder的父类Striped64中的Cell数组类型的成员变量。每个Cell对象中都包含一个value值，并提供对这个value值的CAS操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class Cell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h4><p>我们首先来看一下LongAdder的add函数，其会多次尝试CAS操作将值进行累加，如果成功了就直接返回，失败则继续执行。代码比较复杂，而且涉及的情况比较多，我们就以梳理历次尝试CAS操作为主线，讲清楚这些CAS操作的前提条件和场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 当cells数组为null时，会进行第一次cas操作尝试。</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == null || </span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            // 当cells数组不为null，并且通过getProbe() &amp; m</span><br><span class="line">            // 定位的Cell对象不为null时进行第二次CAS操作。</span><br><span class="line">            // 如果执行不成功，则进入longAccumulate函数。</span><br><span class="line">            longAccumulate(x, null, uncontended); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用casBase函数，对base变量进行CAS累加。</p><p><img src="https://upload-images.jianshu.io/upload_images/623378-39fea917eb75cd7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>我们来看一下casBase函数相关的源码吧。我们可以认为变量base就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发量逐渐提高时，casBase函数会失败。如果cells数组为null或为空,就直接调用longAccumulate方法。因为cells为null或在为空，说明cells未</p><p>初始化，所以调用longAccumulate进行初始化。否则继续判断。<br> 如果cells中已经初始化，就继续进行后续判断。我们先来理解一下getProbe() &amp; m的这个操作吧，可以把这个操作当作一次计算”hash”值，然后将cells中这个位置的Cell对象赋值给变量a。如果变量a不为null，那么就调用该对象的cas方法去设置其value值。如果a为null，或在cas赋值发生冲突，那么调用longAccumulate方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/623378-8433413840b2a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><h4 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h4><p>longAccumulate函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想。</p><p> 首先，我们都知道只有当对base的cas操作失败之后，LongAdder才引入Cell数组．所以在longAccumulate中就是对Cell数组进行操作，分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作。</p><p> 在这段代码中，关于cellBusy的cas操作构成了一个SpinLock，这就是经典的SpinLock的编程技巧，大家可以学习一下。</p><p> 我们先来看一下longAccumulate的主体代码，首先是一个无限for循环，然后根据cells数组的状态来判断是要进行cells数组的初始化，还是进行对象添加或者扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final void longAccumulate(long x, LongBinaryOperator fn,</span><br><span class="line">                             boolean wasUncontended) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       if ((h = getProbe()) == 0) &#123; </span><br><span class="line">           //获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同</span><br><span class="line">           ThreadLocalRandom.current(); </span><br><span class="line">       //初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。</span><br><span class="line">           h = getProbe();</span><br><span class="line">           wasUncontended = true;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean collide = false;</span><br><span class="line">       for (;;) &#123; //cas经典无限循环，不断尝试</span><br><span class="line">           Cell[] as; Cell a; int n; long v;</span><br><span class="line">           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123; </span><br><span class="line">           // cells不为null,并且数组size大于0,表示cells已经初始化了</span><br><span class="line">           // 初始化Cell对象并设置到数组中或者进行数组扩容</span><br><span class="line">           &#125;</span><br><span class="line">           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">           //cells数组未初始化，获得cellsBusy lock,进行cells数组的初始化</span><br><span class="line">           // cells数组初始化操作</span><br><span class="line">           &#125;</span><br><span class="line">          //如果初始化数组失败了，那就再次尝试一下直接cas base变量，</span><br><span class="line">          // 如果成功了就直接返回，这是最后一个进行CAS操作的地方。</span><br><span class="line">           else if (casBase(v = base, ((fn == null) ? v + x :</span><br><span class="line">                                       fn.applyAsLong(v, x))))</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进行Cell数组代码如下所示，它首先调用casCellsBusy函数获取了cellsBusy‘锁’，然后进行数组的初始化操作，最后将cellBusy’锁’释放掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 注意在进入这段代码之前已经casCellsBusy获得cellsBusy这个锁变量了。</span><br><span class="line">boolean init = false;</span><br><span class="line">try &#123;</span><br><span class="line">    if (cells == as) &#123;</span><br><span class="line">        Cell[] rs = new Cell[2];</span><br><span class="line">        rs[h &amp; 1] = new Cell(x); //设置x的值为cell对象的value值</span><br><span class="line">        cells = rs;</span><br><span class="line">        init = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    cellsBusy = 0;</span><br><span class="line">&#125;</span><br><span class="line">if (init)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>如果Cell数组已经初始化过了，那么就进行Cell数组的设置或者扩容。这部分代码有一系列的if else的判断，如果前一个条件不成立，才会进入下一条判断。</p><p> 首先，当Cell数组中对应位置的cell对象为null时，表明该位置的Cell对象需要进行初始化，所以使用casCellsBusy函数获取’锁’，然后初始化Cell对象，并且设置进cells数组，最后释放掉’锁’。</p><p> 当Cell数组中对应位置的cell对象不为null，则直接调用其cas操作进行累加。</p><p> 当上述操作都失败后，认为多个线程在对同一个位置的Cell对象进行操作，这个Cell对象是一个“热点”，所以Cell数组需要进行扩容，将热点分散。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ((a = as[(n - 1) &amp; h]) == null) &#123; //通过与操作计算出来需要操作的Cell对象的坐标</span><br><span class="line">    if (cellsBusy == 0) &#123; //volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。</span><br><span class="line">    //当cellsBusy为0时，表示当前可以对cells数组进行操作。 </span><br><span class="line">        Cell r = new Cell(x);//将x值直接赋值给Cell对象</span><br><span class="line">        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;//如果这个时候cellsBusy还是0</span><br><span class="line">        //就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．</span><br><span class="line">        //如果失败了，就会再次执行一次循环</span><br><span class="line">            boolean created = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                Cell[] rs; int m, j;</span><br><span class="line">                //判断cells是否已经初始化，并且要操作的位置上没有cell对象．</span><br><span class="line">                if ((rs = cells) != null &amp;&amp;</span><br><span class="line">                    (m = rs.length) &gt; 0 &amp;&amp;</span><br><span class="line">                    rs[j = (m - 1) &amp; h] == null) &#123;</span><br><span class="line">                    rs[j] = r;　//将之前创建的值为x的cell对象赋值到cells数组的响应位置．</span><br><span class="line">                    created = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉</span><br><span class="line">                //将cellBusy设置为0就是释放锁．</span><br><span class="line">                cellsBusy = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (created)</span><br><span class="line">                break;　//如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value</span><br><span class="line">            continue; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = false; //未发生碰撞</span><br><span class="line">&#125;</span><br><span class="line">else if (!wasUncontended)//是否已经发生过一次cas操作失败</span><br><span class="line">    wasUncontended = true; //设置成true,以便第二次进入下一个else if 判断</span><br><span class="line">else if (a.cas(v = a.value, ((fn == null) ? v + x :</span><br><span class="line">                            fn.applyAsLong(v, x))))</span><br><span class="line">    　//fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果</span><br><span class="line">    //就直接返回</span><br><span class="line">    break;</span><br><span class="line">else if (n &gt;= NCPU || cells != as)</span><br><span class="line">　　//如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．</span><br><span class="line">    collide = false;</span><br><span class="line">else if (!collide)</span><br><span class="line">    collide = true;</span><br><span class="line">else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">　　//再次获得cellsBusy这个spinLock,对数组进行resize</span><br><span class="line">    try &#123;</span><br><span class="line">        if (cells == as) &#123;//要再次检测as是否等于cells以免其他线程已经对cells进行了操作．</span><br><span class="line">            Cell[] rs = new Cell[n &lt;&lt; 1]; //扩容一倍</span><br><span class="line">            for (int i = 0; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            cells = rs;//赋予cells一个新的数组对象</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cellsBusy = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = false;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br><span class="line">h = advanceProbe(h);//由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入图片说明"></p><p>后记<br> 本篇文章写的不是很好，我写完之后又看了一遍coolshell上的关于LongAdder的文章，感觉自己没有人家写的那么简洁明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章来源： https://yq.aliyun.com/articles/688822</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LongAdder解析&quot;&gt;&lt;a href=&quot;#LongAdder解析&quot; class=&quot;headerlink&quot; title=&quot;LongAdder解析&quot;&gt;&lt;/a&gt;LongAdder解析&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p1.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;摘要： 对`LongAdder`的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于`AtomicLong`来说，更加适合写多读少的并发情景。今天，我们就研究一下`LongAdder`的原理，探究一下它如此高效的原因。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>java并发计数器分析</title>
    <link href="https://www.zengmanhua.cn/2019/05/22/java%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>https://www.zengmanhua.cn/2019/05/22/java并发计数器分析/</id>
    <published>2019-05-22T11:04:00.000Z</published>
    <updated>2019-05-24T05:13:28.268Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://prl6c63q7.bkt.clouddn.com/p12.jpg" alt></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><pre><code>一提到线程安全的并发计数器，AtomicLong 必然是第一个被联想到的工具。Atomic* 一系列的原子类以及它们背后的 CAS 无锁算法，常常是高性能，高并发的代名词。本文将会阐释，在并发场景下，使用 AtomicLong 来充当并发计数器将会是一个糟糕的设计，实际上存在不少 AtomicLong 之外的计数器方案。近期我研究了一些 Jdk1.8 以及 JCTools 的优化方案，并将它们的对比与实现细节整理于此。</code></pre><a id="more"></a><h4 id="AtomicLong-的前世今生"><a href="#AtomicLong-的前世今生" class="headerlink" title="AtomicLong 的前世今生"></a>AtomicLong 的前世今生</h4><pre><code>在 Java 中，Atomic* 是高效的，这得益于 sun.misc.Unsafe 提供的一系列底层 API，使得 Java 这样的高级语言能够直接和硬件层面的 CPU 指令打交道。并且在 Jdk1.7 中，这样的底层指令可以配合 CAS 操作，达到 Lock-Free。在 Jdk1.7 中，AtomicLong 的关键代码如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        long current = get();</span><br><span class="line">        long next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(long expect, long update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. get() 方法 volatile 读当前 long 值2. 自增3. 自旋判断新值与当前值4. 自旋成功，返回；否则返回 1我们特别留意到 Jdk1.7 中 unsafe 使用的方法是 compareAndSwapLong，它与       x86 CPU 上的 LOCK CMPXCHG 指令对应，并且在应用层使用 while(true) 完成自     旋，这个细节在 Jdk1.8 中发生了变化。在 Jdk1.8 中，AtomicLong 的关键代码如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">return unsafe.getAndAddLong(this, valueOffset, 1L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk1.7 的 CAS 操作已经不复存在了，转而使用了 getAndAddLong 方法，它与 x86 CPU 上的 LOCK XADD 指令对应，以原子方式返回当前值并递增（fetch and add）。</p><figure class="highlight plain"><figcaption><span>Atomic* 高效的原因，回答 CAS 是不够全面且不够严谨的，Jdk1.7 的 unsafe.compareAndSwapLong 以及 Jdk1.8 的 unsafe.getAndAddLong 才是关键，且 Jdk1.8 中不存在 CAS。 ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Jdk1.8 AtomicLong 相比 Jdk1.7 AtomicLong 的表现是要优秀的，这点我们将在后续的测评中见证。</span><br><span class="line"></span><br><span class="line">#### Jdk1.8 AtomicLong 相比 Jdk1.7 AtomicLong 的表现是要优秀的，这点我们将在后续的测评中见证。</span><br><span class="line"></span><br><span class="line">无论在 Jdk1.7 还是 Jdk1.8 中，Atomic* 的开销都是很大的，主要体现在：</span><br></pre></td></tr></table></figure><ol><li><p>高并发下，CAS 操作可能会频繁失败，真正更新成功的线程占少数。(Jdk1.7 独有的问题)</p></li><li><p>我之前的文章中介绍过“伪共享” (false sharing) 问题，但在 CAS 中，问题则表现的更为直接，这是“真共享”，与”伪共享“存在相同的问题：缓存行失效，缓存一致性开销变大。</p></li><li><p>底层指令的开销不见得很低，无论是 LOCK XADD 还是 LOCK CMPXCHG，想深究的朋友可以参考 instruction_tables ，（这一点可能有点钻牛角尖，但不失为一个角度去分析高并发下可行的优化）</p></li><li><p>Atomic<em> 所做的，比我们的诉求可能更大，有时候我们只需要计数器具备线程安全地递增这样的特性，但 Atomic</em> 的相关操作每一次都伴随着值的返回。他是个带返回值的方法，而不是 void 方法，而多做了活大概率意味着额外的开销。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">抛开上述导致 AtomicLong 慢的原因，AtomicLong 仍然具备优势：</span><br></pre></td></tr></table></figure></p></li><li><p>上述的第 4 点换一个角度也是 AtomicLong 的有点，相比下面要介绍的其他计数器方案，AtomicLong 能够保证每次操作都精确的返回真实的递增值。你可以借助 AtomicLong 来做并发场景下的递增序列号方案，注意，本文主要讨论的是计数器方案，而不是序列号方案。</p></li><li><p>实现简单，回到那句话：“简单的架构通常性能不高，高性能的架构通常复杂度很高”，AtomicLong 属于性能相对较高，但实现极其简单的那种方案，因为大部分的复杂性，由 JMM 和 JNI 方法屏蔽了。相比下面要介绍的其他计数器实现，AtomicLong 真的太“简易”了。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![upload successful](http://prl6c63q7.bkt.clouddn.com/AtomicLongSpeet.png)</span><br></pre></td></tr></table></figure></p></li></ol><p>横向对比，写的性能相比读的性能要差很多，在 20 个线程下写性能比读性能差距了 4~5 倍。</p><p>纵向对比，主要关注并发写，线程竞争激烈的情况下，单次自增耗时从 22 ns 增长为了 488 ns，有明显的性能下降。</p><p>实际场景中，我们需要统计系统的 qps、接口调用次数，都需要使用到计数的功能，写才是关键，并不是每时每刻都需要关注自增后的返回值，而 AtomicLong 恰恰在核心的写性能上有所欠缺。由此引出其他计数器方案。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 认识 LongAdder</span><br><span class="line">Doug Lea 在 JDK1.8 中找到了一个上述问题的解决方案，他实现了一个 LongAdder 类。</span><br></pre></td></tr></table></figure></p><p>@since 1.8<br>@author Doug Lea<br>public class LongAdder extends Striped64 implements Serializable {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LongAdder 的 API 如下</span><br><span class="line"></span><br><span class="line">![upload successful](http://prl6c63q7.bkt.clouddn.com/longAddr.png)</span><br><span class="line"></span><br><span class="line">你应当发现，LongAdder 和 AtomicLong 明显的区别在于，increment 是一个 void 方法。直接来看看 LongAdder 的性能表现如何。(LA = LongAdder, AL = AtomicLong, 单位 ns/op)</span><br><span class="line"></span><br><span class="line">![upload successful](http://prl6c63q7.bkt.clouddn.com/longAddrSpett.png)</span><br><span class="line"></span><br><span class="line">我们从中可以发现一些有意思的现象，网上不少很多文章没有从读写上对比二者，直接宣称 LongAdder 性能优于 AtomicLong，其实不太严谨。在单线程下，并发问题没有暴露，两者没有体现出差距；随着并发量加大，LongAdder 的 increment 操作更加优秀，而 AtomicLong 的 get 操作则更加优秀。鉴于在计数器场景下的特点—写多读少，所以写性能更高的 LongAdder 更加适合。</span><br><span class="line"></span><br><span class="line">#### LongAdder 写速度快的背后</span><br><span class="line"></span><br><span class="line">网上分析 LongAdder 源码的文章并不少，我不打算详细分析源码，而是挑选了一些必要的细节以及多数文章没有提及但我认为值得分析的内容。</span><br><span class="line"></span><br><span class="line">![upload successful](http://prl6c63q7.bkt.clouddn.com/cell.png)</span><br></pre></td></tr></table></figure></p><ol><li>Cell 设计减少并发修改时的冲突<br>在 LongAdder 的父类 Striped64 中存在一个 volatile Cell[] cells; 数组，其长度是 2 的幂次方，每个 Cell 都填充了一个 @Contended 的 Long 字段，为了避免伪共享问题。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` @sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    // ... ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><figcaption><span>通过一系列算法，将计数结果分散在了多个 Cell 中，Cell 会随着并发量升高时发生扩容，最坏情况下 Cell </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">public long sum() &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    long sum = base;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>ConcurrentHashMap 中的 size() 中也存在，毕竟他们的作者都是 Doug Lea。```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>并发场景下高效获取随机数</li></ol><p>LongAdder 内部算法需要获取随机数，而 Random 类在并发场景下也是可以优化的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>ThreadLocalRandom random =  ThreadLocalRandom.current();<br>random.nextInt(5);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```使用 ThreadLocalRandom 替代 Random，同样出现在了 LongAdder 的代码中。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. longAccumulate</span><br><span class="line">longAccumulate 方法是 LongAdder 的核心方法，内部存在大量的分支判断。首先和 Jdk1.7 的 AtomicLong 一样，它使用的是 UNSAFE.compareAndSwapLong 来完成自旋，不同之处在于，其在初次 cas 方式失败的情况下(说明多个线程同时想更新这个值)，尝试将这个值分隔成多个 Cell，让这些竞争的线程只负责更新自己所属的 Cell，这样将竞争压力分散开。</span><br></pre></td></tr></table></figure><h4 id="LongAdder-的前世今生"><a href="#LongAdder-的前世今生" class="headerlink" title="LongAdder 的前世今生"></a>LongAdder 的前世今生</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实在 Jdk1.7 时代，LongAdder 还未诞生时，就有一些人想着自己去实现一个高性能的计数器了，比如一款 Java 性能监控框架 dropwizard/metrics 就做了这样事，在早期版本中，其优化手段并没有 Jdk1.8 的 LongAdder 丰富，而在 metrics 的最新版本中，其已经使用 Jdk1.8 的 LongAdder 替换掉了自己的轮子。在最后的测评中，我们将 metrics 版本的 LongAdder 也作为一个参考对象。</span><br></pre></td></tr></table></figure><h4 id="JCTools-中的-ConcurrentAutoTable"><a href="#JCTools-中的-ConcurrentAutoTable" class="headerlink" title="JCTools 中的 ConcurrentAutoTable"></a>JCTools 中的 ConcurrentAutoTable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并非只有 LongAdder 考虑到了并发场景下计数器的优化，大名鼎鼎的并发容器框架 JCTool 中也提供了和今天主题相关的实现，虽然其名称和 Counter 看似没有关系，但通过其 Java 文档和 API ，可以发现其设计意图考虑到了计数器的场景。</span><br></pre></td></tr></table></figure><p><img src="http://prl6c63q7.bkt.clouddn.com/ConcurrentAutoTable%20.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在最后的测评中，我们将 JCTools 的 ConcurrentAutoTable 也作为一个参考对象。</span><br></pre></td></tr></table></figure></p><h4 id="最终测评"><a href="#最终测评" class="headerlink" title="最终测评"></a>最终测评</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jdk1.7 的 AtomicLong，Jdk1.8 的 AtomicLong，Jdk 1.8 的 LongAdder，Metrics 的 LongAdder，JCTools 的 ConcurrentAutoTable，我对这五种类型的计数器使用 JMH 进行基准测试。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Counter &#123;</span><br><span class="line">    void inc();</span><br><span class="line">    long get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将 5 个类都适配成 Counter 接口的实现类，采用 @State(Scope.Group)，@Group 将各组测试用例进行隔离，尽可能地排除了互相之间的干扰，由于计数器场景的特性，我安排了 20 个线程进行并发写，1 个线程与之前的写线程共存，进行并发读。Mode=avgt 代表测试的是方法的耗时，越低代表性能越高。</span><br></pre></td></tr></table></figure><p><img src="http://prl6c63q7.bkt.clouddn.com/test.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果我们只关注 inc 即写性能，可以发现 jdk1.8 的 LongAdder 表现的最为优秀，ConcurrentAutoTable 以及两个版本的 LongAdder 在一个数量级之上；1.8 的 AtomicLong 相比 1.7 的 AtomicLong 优秀很多，可以得出这样的结论，1.7 的 CAS+LOCK CMPXCHG 方案的确不如 1.8 的 LOCK XADD 来的优秀，但如果与特地优化过的其他计数器方案来进行比较，便相形见绌了。</span><br><span class="line"></span><br><span class="line">如果关注 get 性能，虽然这意义不大，但可以见得，AtomicLong 的 get 性能在高并发下表现依旧优秀，而 LongAdder 组合求值的特性，导致其性能必然存在一定下降，位列第二梯队，而 ConcurrentAutoTable 的并发读性能最差。</span><br><span class="line"></span><br><span class="line">关注整体性能，CounterBenchmark.rw 是对一组场景的整合打分，可以发现，在我们模拟的高并发计数器场景下，1.8 的 LongAdder 获得整体最低的延迟 98 ns，相比性能最差的 Jdk1.7 AtomicLong 实现，高了整整 10 倍有余，并且，随着并发度提升，这个数值还会增大。</span><br></pre></td></tr></table></figure><h4 id="AtomicLong-可以被废弃吗？"><a href="#AtomicLong-可以被废弃吗？" class="headerlink" title="AtomicLong 可以被废弃吗？"></a>AtomicLong 可以被废弃吗？</h4><p>既然 LongAdder 的性能高出 AtomicLong 这么多，我们还有理由使用 AtomicLong 吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文重点讨论的角度还是比较局限的：单机场景下并发计数器的高效实现。AtomicLong 依然在很多场景下有其存在的价值，例如一个内存中的序列号生成器，AtomicLong 可以满足每次递增之后都精准的返回其递增值，而 LongAdder 并不具备这样的特性。LongAdder 为了性能而丧失了一部分功能，这体现了计算机的哲学，无处不在的 trade off。</span><br></pre></td></tr></table></figure><h4 id="高性能计数器总结"><a href="#高性能计数器总结" class="headerlink" title="高性能计数器总结"></a>高性能计数器总结</h4><ul><li><p>AtomicLong ：并发场景下读性能优秀，写性能急剧下降，不适合作为高性能的计数器方案。内存需求量少。</p></li><li><p>LongAdder ：并发场景下写性能优秀，读性能由于组合求值的原因，不如直接读值的方案，但由于计数器场景写多读少的缘故，整体性能在几个方案中最优，是高性能计数器的首选方案。由于 Cells 数组以及缓存行填充的缘故，占用内存较大。</p></li><li><p>ConcurrentAutoTable ：拥有和 LongAdder 相近的写入性能，读性能则更加不如 LongAdder。它的使用需要引入 JCTools 依赖，相比 Jdk 自带的 LongAdder 并没有优势。但额外说明一点，ConcurrentAutoTable 的使用并非局限于计数器场景，其仍然存在很大的价值。</p></li></ul><p><strong><em>在前面提到的性能监控框架 Metrics，以及著名的熔断框架 Hystrix 中，都存在 LongAdder 的使用场景，有兴趣的朋友快去实践一下 LongAdder 吧。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">本文所有的 JMH 测试代码，均可在我的 github 中获得：https://github.com/lexburner/JMH-samples.git</span><br><span class="line"></span><br><span class="line">微信不支持外部超链接，文中相关仓库附录：</span><br><span class="line"></span><br><span class="line">Netflix/Hystrix : https://github.com/Netflix/Hystrix</span><br><span class="line"></span><br><span class="line">Metrics : https://github.com/dropwizard/metrics</span><br><span class="line"></span><br><span class="line">JCTools : https://github.com/JCTools/JCTools</span><br><span class="line"></span><br><span class="line">instruction_tables : https://www.agner.org/optimize/instruction_tables.pdf</span><br><span class="line"></span><br><span class="line">本文转载于：https://mp.weixin.qq.com/s/yAvJFZWxfKb38IDMjQd5zg?spm=a2c4e.11153940.blogcont651530.11.303e7bebu6FTOM</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p12.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;一提到线程安全的并发计数器，AtomicLong 必然是第一个被联想到的工具。Atomic* 一系列的原子类以及它们背后的 CAS 无锁算法，常常是高性能，高并发的代名词。本文将会阐释，在并发场景下，使用 AtomicLong 来充当并发计数器将会是一个糟糕的设计，实际上存在不少 AtomicLong 之外的计数器方案。近期我研究了一些 Jdk1.8 以及 JCTools 的优化方案，并将它们的对比与实现细节整理于此。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习番外篇" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之基础知识</title>
    <link href="https://www.zengmanhua.cn/2019/05/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.zengmanhua.cn/2019/05/21/并发编程之基础知识/</id>
    <published>2019-05-21T07:11:40.000Z</published>
    <updated>2019-05-24T05:14:27.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lombox"><a href="#Lombox" class="headerlink" title="Lombox"></a>Lombox</h3><p><img src="http://prl6c63q7.bkt.clouddn.com/p13.jpg" alt></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Lombok项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能val，等等。</p><a id="more"></a><p>除了官方介绍中，并不多相关文章，特意挑了 <strong><em>一篇文章中相关内容</em></strong></p><pre><code>lombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码。特别是相对于 POJO。简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。</code></pre><h4 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h4><p>@slf4j、@Setter、@Getter、@NoArgsConstructor(注解在类上：为类提供一个无参的构造方法)、@AllArgsConstructor(注解在类上；为类提供一个全参的构造方法)</p><pre><code>@NoArgsConstructor //注解在类上：为类提供一个无参的构造方法@AllArgsConstructor//注解在类上；为类提供一个全参的构造方法public class Person {  //@Getter @Setter 注解在属性上；为属性提供 setting 方法 getting方法  @Setter @Getter private int pid;  @Setter @Getter private String pname;  @Setter @Getter private int sage; }</code></pre><h3 id="基础知识讲解与核心知识准备"><a href="#基础知识讲解与核心知识准备" class="headerlink" title="基础知识讲解与核心知识准备"></a>基础知识讲解与核心知识准备</h3><h4 id="并发与高并发基本概念"><a href="#并发与高并发基本概念" class="headerlink" title="并发与高并发基本概念"></a>并发与高并发基本概念</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><pre><code>并发：同时拥有两个或者多个线程，如果程序在单核处理器运行，多个线程将交替地换入或者换出内存，这些线程是同时&quot;存在&quot;的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将会分配到一个处理器核上，因此可以同时运行并行：系统中有多个任务同时存在可称之为“并发”，系统内有多个任务同时执行可称之为“并行”；并发是并行的子集。如果说并发就是在一台处理器上&quot;同时&quot;处理多个任务，那么并行就是在多台处理器上同时处理多个任务；个人理解是，在单核CPU系统上，并行是无法实现的，只可能存在并发而不可能存在并行。</code></pre><p>    高并发：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常指，通过设计保证系统能够同时并行处理很多请求。</p><h5 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h5><pre><code>并发：多个线程操作相同的资源，保证线程安全，合理使用资源高并发：服务能同时处理很多请求，提高程序性能；如系统集中收到大量的请求（12306的抢票系统），导致系统在某段时间类执行大量的操作，包括对资源的请求、数据库的操作等等，如果高并发处理不好，不仅仅降低用户的体验度，请求时间变长，同时也可能导致系统宕机，甚至导致OOM（Out Of Memory）异常，如果想要系统适应高并发状态，就要有多个方面进行系统优化，包括硬件、网络、系统架构、开发语言的选取、数据结构的应用、算法的优化等等，这个时候谈论的是如何提供现有程序的性能，对高并发场景提供一些解决方案、手段等等</code></pre><h5 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h5><pre><code>在多线程并发环境下，如果不采取特殊手段，普通的累加结果很可能是错的。错的原因可能涉及到计算机原理以及JAVA方面的一些知识。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9577794-40a2a48a0a75d1df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>Main Memory : 主存Cache : 高速缓存，数据的读取和存储都经过此高速缓存CPU Core :  CPU核心Bus :  系统总线  CUP Core 与 Cache 之间有一条快速通道，Main Memory 与 Cache 关联在 Bus 上，同时 Bus 还用于其他组件 的通信，在Cache出现不久后，系统变得更加复杂，Cache与Main Memory中速度的差异拉大，直到加入另一级的Cache，新加入的Cache 比 一级 Cache 更大，但是更慢，由于从加大一级Cache的做法，从经济上是行不通的，所以有了二级Cache，甚至已经有三级 Cache</code></pre><h5 id="为什么需要CPU-CACHE"><a href="#为什么需要CPU-CACHE" class="headerlink" title="为什么需要CPU CACHE?"></a>为什么需要CPU CACHE?</h5><pre><code>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，这样会使CPU花费很长时间等待数据到来或把数据写入内存。所以Cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：CPU - &gt; CACHE - &gt; MEMORY）</code></pre><h5 id="CPU-CACHE-意义"><a href="#CPU-CACHE-意义" class="headerlink" title="CPU CACHE 意义"></a>CPU CACHE 意义</h5><pre><code>缓存的容量远远小于主存，因此出现缓存不命中的情况在所难免，既然缓存不能包含CPU所需要的所有数据，那么Cache的存在真的有意义吗?CPU缓存存在的意义分两点（局部性原理）：时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问空间局限性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问  缓存的工作原理是当CPU要读取一个数据时，首先从缓存中查找，如果找到就立即读取并运送给CPU处理；如果没有找到，就用相对慢的速度内存中读取并运送给CPU处理，同时把这个数据所在的数据块调入缓存中，可以使得以后对整块数据的读取都从缓存中进行，不必再调用内存。  正是这样的读取机制使CPU读取缓存的命中率非常高（大多数CPU可达90%左右），也就是说CPU下一次要读取的数据90%都在缓存中，大约10%需要从内存读取。</code></pre><h5 id="缓存一致性（MESI）"><a href="#缓存一致性（MESI）" class="headerlink" title="缓存一致性（MESI）"></a>缓存一致性（MESI）</h5><pre><code>缓存一致性用于保证多个CPU Cache之间缓存共享数据的一致性，定义了Cache Line四种状态，而CPU对Cache的四种操作，可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候 ，需要对Cache Line作出相应的修改，从而保证数据在多个缓存之间的一致性  Cache Line ： 是cache与内存数据交换的最小单位，根据操作系统一般是32byte或64byte。在MESI协议中，状态可以是M、E、S、I，地址则是cache line中映射的内存地址，数据则是从内存中读取的数据。  MESI其实是四种状态的缩写：M（modify）修改、E（exclusive）独占、S（shared）共享、I（invalid）失效。  Cache 操作： MESI协议中，每个cache的控制器不仅知道自己的操作（local read和local write），通过监听也知道其他CPU中cache的操作（remote read和remote write）。对于自己本地缓存有的数据，CPU仅需要发起local操作，否则发起remote操作，从主存中读取数据，cache控制器通过总线监听，仅能够知道其他CPU发起的remote操作，但是如果local操作会导致数据不一致性，cache控制器会通知其他CPU的cache控制器修改状态。</code></pre><h5 id="乱序执行优化"><a href="#乱序执行优化" class="headerlink" title="乱序执行优化"></a>乱序执行优化</h5><pre><code>处理器为提高运算速度而做出违背代码原有顺序的优化举个例子：计算 a * b ，a =10 ，b = 200 ，则 result = a * b = 2000代码编写顺序：a=10 -&gt; b=200 -&gt; result = a * bCPU乱序执行优化可能会发生执行顺序为：b=200 -&gt; a=10 -&gt; result = a * bCPU乱序执行优化不会对结果造成影响，在单核时代，处理器保证做出的优化，不会导致执行的结果远离预期的目标，但是在多核环境下并非如此。首先在多核环境中，同时会有多个核执行指令，每个核的指定都可能会被乱序优化，另外，处理器还引用了L1、L2等缓存机制，每个核都有自己的缓存，这就导致了逻辑次序上后写入内存的数据，未必真的最后写入，最终带来了这样的一个问题：如果我们不做任何防护措施，处理器最终得到的结果和我们逻辑得出的结果大不相同。比如我们在其中的一个核中执行数据写入操作，并在最后写一个标记，用来标记数据已经准备好了，然后从另外一个核上，通过那个标志，来判断数据是否已经就绪，这种做法它就存在一定的风险，标记位先被写入，但数据操作并未完成（可能是计算为完成、也可能是数据没有从缓存刷新到主存当中）， 最终导致另外的核使用了错误的数据。</code></pre><h5 id="Java-内存模型（Java-Memory-Model，JMM）"><a href="#Java-内存模型（Java-Memory-Model，JMM）" class="headerlink" title="Java 内存模型（Java Memory Model，JMM）"></a>Java 内存模型（Java Memory Model，JMM）</h5><pre><code>CPU缓存一致性和乱序执行优化，在多核多并发下，需要额外做很多的事情，才能保证程序的执行，符合我们的预期。那么JVM（Java Virtual Machine (Java虚拟机)）是如何解决这些问题的?为了屏蔽掉各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台下都能达到一致的并发效果，JMV规范中定义了JMM （Java Memory Model (Java 内存模型)）。 JMM是一种规范，它规范了JVM与计算机内存是如何协同工作的，它规定一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步的访问共享变量。</code></pre><h5 id="JVM内存分配概念"><a href="#JVM内存分配概念" class="headerlink" title="JVM内存分配概念"></a>JVM内存分配概念</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-e9d8060908de35f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>JVM内存分配的两个概念：Stack（栈）和Heap（堆）。  Java中的Heap是运行时数据区，由垃圾回收负责，它的优势是动态的分配内存大小，生存期也不必事先告诉编译器，在运行时动态分配内存，Java的垃圾收集器，会自动回收不再使用的数据。但是也有缺点，由于是要在运行时动态分配内存，因此存取速度相对较慢。  Java中的Stack优势是存取速度比Heap要快，仅次于计算机中的寄存器，栈中的数据是可以共享的，但是它的缺点是，存在栈中数据的大小和生存期必须是确定的，缺乏灵活性，主要存放一些基本类型的变量。  JMM要求调用栈和本地变量存放在线程栈中，对象存放在堆上。一个本地变量可能指向一个对象的引用，引用这个本地变量是存放在线程栈上，而对象本身是存放在堆上的。一个对象可能包含方法，这些方法可能包含本地变量，这些本地变量还是存放在线程栈中，即使这些方法所属的对象存放在堆上。一个对象的成员变量可能会随着这个对象自身存放在堆上，不管这个成员对象是原始类型还是引用类型，静态成员变量跟随着类的定义一起存放在堆上。存放在堆上的对象，可以被所持有对这个对象引用线程的访问。  当一个线程可以访问一个对象的时候，它也可以访问该对象的成员变量，如果两个线程同时调用同一个对象的同一个方法，将会都访问该对象的成员变量，但是每一个线程都拥有了这个成员变量的私有拷贝。</code></pre><h5 id="计算机内存硬件架构"><a href="#计算机内存硬件架构" class="headerlink" title="计算机内存硬件架构"></a>计算机内存硬件架构</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-63c75dfa96cdfd1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/951/format/webp" alt="upload successful"></p><pre><code>CPU，一台现代计算机拥有两个或多个CPU，其中一些CPU还有多核，从这一点可以看出，在一个有两个或多个CPU的现代计算机上，同时运行多个线程是非常有可能的，而且每个CPU在某一个时刻，运行一个线程是肯定没有问题的，这意味着，如果Java程序是多线程的，在Java程序中，每个CPU上一个线程是可能同时并发执行的。  CPU Refisters（寄存器），每个CPU都包含一系列的寄存器，它们是CPU内存的基础，CPU在寄存器中执行操作的速度远大于在主存上执行的速度，这是因为CPU访问寄存器的速度远大于主存。  Cache（高速缓存），由于计算机的存储设备与处理器运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速的进行，当运算结束后，在从缓存同步到内存中。这样处理器就无需等待缓慢的内存读写，CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度要慢。  Main Memory（主存），随机存取存储器（random access memory，RAM）又称作“随机存储器&quot;，一个计算机包含一个主存，所有的CPU都可以访问主存，主存通常比CPU中的缓存大得多。</code></pre><h5 id="JVM-与-Computer"><a href="#JVM-与-Computer" class="headerlink" title="JVM 与 Computer"></a>JVM 与 Computer</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-8687192be85206f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><pre><code>JVM 与 Computer 内存架构存在差异，硬件内存并无区分栈与堆，对于硬件而言，所有的栈和堆都分布在主内存中，可能会出现在高速缓存、寄存器中。</code></pre><h5 id="内存模型抽象结构"><a href="#内存模型抽象结构" class="headerlink" title="内存模型抽象结构"></a>内存模型抽象结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-ef8f9cbb9a839f3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/960/format/webp" alt="upload successful"></p><h5 id="Java内存模型-同步八种操作"><a href="#Java内存模型-同步八种操作" class="headerlink" title="Java内存模型 - 同步八种操作"></a>Java内存模型 - 同步八种操作</h5><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值存放工作内存的变量副本中</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存中，以便随后的write的操作</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</li></ul><h5 id="Java内存模型-同步规则"><a href="#Java内存模型-同步规则" class="headerlink" title="Java内存模型 - 同步规则"></a>Java内存模型 - 同步规则</h5><ol><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作，但Java内存模型只要求上述操作必须按顺序执行，而没有保证是连续执行</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次与执行lock后，只有执行相同次数的unlock，变量才会被解锁。lock和unlock必须成对出现</li><li>如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把变量同步到主内存中（执行store和write操作）</li></ol><h5 id="Java-内存模型-同步操作与规则"><a href="#Java-内存模型-同步操作与规则" class="headerlink" title="Java 内存模型 - 同步操作与规则"></a>Java 内存模型 - 同步操作与规则</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-60bc2de2383c6545.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><h5 id="并发的优势与风险"><a href="#并发的优势与风险" class="headerlink" title="并发的优势与风险"></a>并发的优势与风险</h5><p><img src="https://upload-images.jianshu.io/upload_images/9577794-6908ee45fdcfd1dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="upload successful"></p><h5 id="并发编程与线程安全"><a href="#并发编程与线程安全" class="headerlink" title="并发编程与线程安全"></a>并发编程与线程安全</h5><pre><code>代码所在的进程，有多个线程同时运行，而这些线程可能会同时运行同一段代码，如果每次运行结果和单线程预期结果一致，变量值也和预期一致，则认为这是线程安全的。简单的说，就是并发环境下，得到我们期望正确的结果。对应的一个概念就是线程不安全，就是不提供数据访问保护，有可能出现多个线程，先后更改数据，造成所得到的数据是脏数据，也可能是计算错误。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Lombox&quot;&gt;&lt;a href=&quot;#Lombox&quot; class=&quot;headerlink&quot; title=&quot;Lombox&quot;&gt;&lt;/a&gt;Lombox&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p13.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Lombok项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能val，等等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.zengmanhua.cn/categories/technology/"/>
    
    
      <category term="java并发系统学习" scheme="https://www.zengmanhua.cn/tags/java%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>时光荏苒，蹉跎了谁的年华</title>
    <link href="https://www.zengmanhua.cn/2019/05/18/%E6%97%B6%E5%85%89%E8%8D%8F%E8%8B%92%EF%BC%8C%E8%B9%89%E8%B7%8E%E4%BA%86%E8%B0%81%E7%9A%84%E5%B9%B4%E5%8D%8E/"/>
    <id>https://www.zengmanhua.cn/2019/05/18/时光荏苒，蹉跎了谁的年华/</id>
    <published>2019-05-18T10:04:15.000Z</published>
    <updated>2019-05-24T05:15:00.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://prl6c63q7.bkt.clouddn.com/p14.jpg" alt="输入图片说明"></p><p><strong>当清晨的一缕阳光透过窗帘上的空隙映照在沉睡的脸庞时，微微张开的双眼朦胧地注视着周遭的一切，新的一天悄然而至。</strong> </p><p>　　 <strong>——题记</strong> </p><a id="more"></a><pre><code>时光的单车飞快驶去，岁月的倒影也将消失，白天与黑夜不停的交替，轮回的四季斑驳了谁的岁月，蹉跎了谁的年华。一个人静静地与岁月交错，于平淡之中细细体会生活的深意，去注视，去聆听，去感受那些带着希望的别离以及那些经受沧桑的相逢，不论时光如何飞转，那些落花一样的往事，依然鲜活地存在于我的脑海之中。当岁月和美丽的回忆已成为风中的叹息，我们伤感的眼里也许依然残存旧时的泪痕，模糊了视线，不敢轻易触碰。生活的列车慢慢的前进，有些人下去，也有人上去，不慌不忙的过着行云流水的日子，有的人知道自己的前方在哪里停靠，生活充实而安逸，有些人庸庸碌碌的过着不起波澜的日子，每天无头鸟似的瞎忙，朦胧的眼神向世界宣告着昏暗思想，一个个皮囊悬浮在空气中，没有生机的灵魂过着糜烂的时间。没有归属，无处生根。有时我们在迷茫青春的时候，日子也慢慢地溜走，不留一点痕迹。时光不可阻挡，岁月交错中总要有些思量。人生只有在不短的思考中才会有所进步，有所追求，有了目标的人生才不会孤独和无助，只有让自己的心静下来时一些前方的东西才会明朗的展现在我们的面前。让我们不再迷惑于为所谓的挣扎中，谁的年华没有色彩，谁的青春没有耀眼的光芒，只是在岁月的长河里我们的选择不同，所得到的结局就不同，每个人都需要努力才会得到一切自己所要追求的东西和梦想。生命无常，人生苦短，记忆的时光中我们匆匆走过，走过喧嚣，走过孤寂，时光无情地带走了我们的青春年少，还好我们都在坚持着内心的宁静，岁月的年轮缓缓的从我们身边碾过，往事一幕幕铺陈，让我的生活回忆不至于那么的枯燥，一些美好的记忆还依然鲜活地根植在我的脑海之中。消逝不去，本不该怀旧的年纪，可是我们学不会遗忘，日日夜夜的想念，带着些许的小寂寞，心有不甘常常在无人的街角大声的长啸，发泄着内心的声音，有时候我们会选择相信宿命，认为人与人之间的相遇，就像是上天早已做了安排，人谁也逃不过岁月时光刻下的印迹。时光荏苒，蹉跎了谁的年华，匆匆行走的岁月长河中，有些人只顾着追寻他人的脚步，忘记了自己的方向，忘记了自己的目标和理想，有些人几顾思量不敢走出自己的道路，因而迷失了方向。迷失了自己。有些人默默坚守，把青春的岁月包裹在温热的怀里，载着它踏上梦想的征途，不留一丝遗憾。不留一点别人靠近的距离，就像是陈孝正为自己规划的一厘米的差距，人生没有从头来过的权利。亦没有后悔的权利，做过的事情，不管有些怎样的结局都会成为过往，我们纵使一味的活在过去的时光里也不会改变一点点发生的故事，向着远方，努力的看看前方的路才是对我们自己的肯定，只有心存希望，才会有拼搏的勇气，才有希望去走更远的路，因为值得，所以一路前行，那一路上的心酸往事，慢慢的沉淀在内心平和的深处！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p14.jpg&quot; alt=&quot;输入图片说明&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当清晨的一缕阳光透过窗帘上的空隙映照在沉睡的脸庞时，微微张开的双眼朦胧地注视着周遭的一切，新的一天悄然而至。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;——题记&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.zengmanhua.cn/categories/life/"/>
    
    
      <category term="生活" scheme="https://www.zengmanhua.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.zengmanhua.cn/2019/05/18/hello-world/"/>
    <id>https://www.zengmanhua.cn/2019/05/18/hello-world/</id>
    <published>2019-05-18T03:25:57.306Z</published>
    <updated>2019-05-24T05:16:33.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://prl6c63q7.bkt.clouddn.com/p8.jpg" alt></p><h3 id="welcome-here"><a href="#welcome-here" class="headerlink" title="welcome here !"></a>welcome here !</h3><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://prl6c63q7.bkt.clouddn.com/p8.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;welcome-here&quot;&gt;&lt;a href=&quot;#welcome-here&quot; class=&quot;headerlink&quot; title=&quot;welcome here !&quot;&gt;&lt;/a&gt;welcome here !&lt;/h3&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.zengmanhua.cn/categories/life/"/>
    
    
      <category term="生活" scheme="https://www.zengmanhua.cn/tags/life/"/>
    
  </entry>
  
</feed>
