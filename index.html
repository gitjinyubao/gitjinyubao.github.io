<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "3484a04a"
    });
  daovoice('update');
  </script>






















  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  



  <meta name="description" content="生活源于奋斗">
<meta name="keywords" content="life,java,centos,technology,Internet,movie,read">
<meta property="og:type" content="website">
<meta property="og:title" content="JinYuBao">
<meta property="og:url" content="https://www.zengmanhua.cn/index.html">
<meta property="og:site_name" content="JinYuBao">
<meta property="og:description" content="生活源于奋斗">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JinYuBao">
<meta name="twitter:description" content="生活源于奋斗">



  <link rel="alternate" href="/atom.xml" title="JinYuBao" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://www.zengmanhua.cn/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JinYuBao</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4b71d0039cde751d335fa8488a614ead";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JinYuBao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">生活源于奋斗</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-电影">

    
    
    
      
    

    

    <a href="/movies" rel="section"><i class="menu-item-icon fa fa-fw fa-film"></i> <br>电影</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-音乐">

    
    
    
      
    

    

    <a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i> <br>音乐</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/06/13/Redis持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/13/Redis持久化/" class="post-title-link" itemprop="url">Redis持久化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-13 10:54:32" itemprop="dateCreated datePublished" datetime="2019-06-13T10:54:32+08:00">2019-06-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/13/Redis持久化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/13/Redis持久化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&lt;!DOCTYPE html&gt;</p>
<html lang="zh-cn"><br><body><br><!--done--><br><div id="home"><br>    <div id="main"><br>        <div id="mainContent"><br>            <div class="forFlow"><br><br>## 前言<br><br>在上一篇文章中，介绍了Redis的内存模型，从这篇文章开始，将依次介绍Redis高可用相关的知识&mdash;&mdash;持久化、复制(及读写分离)、哨兵、以及集群。<br><br>本文将先说明上述几种技术分别解决了Redis高可用的什么问题；然后详细介绍Redis的持久化技术，主要是RDB和AOF两种持久化方案；在介绍RDB和AOF方案时，不仅介绍其作用及操作方法，同时介绍持久化实现的一些原理细节及需要注意的问题。最后，介绍在实际使用中，持久化方案的选择，以及经常遇到的问题等。<br><br>## 目录<br><br><a href="#t1">一、Redis高可用概述</a><br><br><a href="#t2">二、Redis持久化概述</a><br><br><a href="#t3">三、RDB持久化</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t31">1. 触发条件</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t32">2. 执行流程</a><br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<a href="#t33">3. RDB文件</a><br><br>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<a href="#t34">4. 启动时加载</a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<a href="#t35">5. <!--[endif]--><span lang="EN-US">RDB常用配置总结</span></a></span><br><br><a href="#t4"><span lang="EN-US">四、AOF持久化</span></a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t41">1. <!--[endif]-->开启<span lang="EN-US">AOF</span></a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t42">2. <!--[endif]-->执行流程</a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t43">3. <!--[endif]-->启动时加载</a></span><br><br><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t44">4. <!--[endif]--><span lang="EN-US">AOF常用配置总结</span></a></span><br><br><a href="#t5">五、方案选择与常见问题</a><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t51">1. <!--[endif]--><span lang="EN-US">RDB和<span lang="EN-US">AOF的优缺点</span></span></a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t52">2. <!--[endif]-->持久化策略选择</a></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t53">3. <!--[endif]--><span lang="EN-US">fork阻塞：<span lang="EN-US">CPU的阻塞</span></span></a></span><br><br><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t54">4.AOF追加阻塞：硬盘的阻塞</a></span></span></span><br><br><!--[if !supportLists]--><span lang="EN-US">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="#t55">5. <!--[endif]--><span lang="EN-US">info命令与持久化</span></a></span><br><br><a href="#t6">六、总结</a><br><br># <a name="t1"></a>一、Redis高可用概述<br><br>在介绍Redis高可用之前，先说明一下在Redis的语境中高可用的含义。<br><br>我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。<br><br>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。<br><br>1.  持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。<br>2.  复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。<br>3.  哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。<br>4.  集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。<br><br># <a name="t2"></a>二、Redis持久化概述<br><br>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。<br><br>Redis持久化分为RDB持久化和AOF持久化<strong>：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；</strong>由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。<br><br>下面依次介绍RDB持久化和AOF持久化；由于Redis各个版本之间存在差异，如无特殊说明，以Redis3.0为准。<br><br># <a name="t3"></a>三、RDB持久化<br><br>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。<br><br>## <a name="t31"></a>1. 触发条件<br><br>RDB持久化的触发分为手动触发和自动触发两种。<br><br>### 1) 手动触发<br><br>save命令和bgsave命令都可以生成RDB文件。<br><br>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085242889-137050862.png" alt><br><br>而bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085309364-1576452765.png" alt><br><br>此时服务器执行日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085325656-76060516.png" alt><br><br>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。<br><br>### 2) 自动触发<br><br><strong>save m n</strong><br><br>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。<br><br>例如，查看redis的默认配置文件(Linux下为redis根目录下的redis.conf)，可以看到如下配置信息：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085420533-1928501600.png" alt><br><br>其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。<br><br><strong>save m n的实现原理</strong><br><br>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。<br><br>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。<br><br>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。<br><br>例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。<br><br>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。<br><br>save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：<br><br>（1）当前时间-lastsave &gt; m<br><br>（2）dirty &gt;= n<br><br><strong>save m n 执行日志</strong><br><br>下图是save m n触发bgsave执行时，服务器打印日志的情况：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085606524-1682958341.png" alt><br><br><strong>其他自动触发机制</strong><br><br>除了save m n 以外，还有一些其他情况会触发bgsave：<br><br><em>   在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点
</em>   执行shutdown命令时，自动执行rdb持久化，如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085620830-1223048825.png" alt><br><br>## <a name="t32"></a>2. 执行流程<br><br>前面介绍了触发bgsave的条件，下面将说明bgsave命令的执行流程，如下图所示(图片来源：<a href="https://blog.csdn.net/a1007720052/article/details/79126253)：" target="_blank" rel="noopener">https://blog.csdn.net/a1007720052/article/details/79126253)：</a><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605085813461-389677620.png" alt><br><br>图片中的5个步骤所进行的操作如下：<br><br>1)&nbsp; Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。<br><br>2)&nbsp; 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令<br><br>3)&nbsp; 父进程fork后，bgsave命令返回&rdquo;Background saving started&rdquo;信息并不再阻塞父进程，并可以响应其他命令<br><br>4)&nbsp; 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换<br><br>5)&nbsp; 子进程发送信号给父进程表示完成，父进程更新统计信息<br><br>## <a name="t33"></a>3. RDB文件<br><br>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。<br><br><strong>存储路径</strong><br><br>RDB文件的存储路径既可以在启动前配置，也可以通过命令动态设定。<br><br>配置：dir配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。<br><br>动态设定：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为config set dir {newdir}和config set dbfilename {newFileName}。如下所示(Windows环境)：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090102836-284073324.png" alt><br><br><strong>RDB文件格式</strong><br><br>RDB文件格式如下图所示（图片来源：《Redis设计与实现》）：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090115749-1746859283.png" alt><br><br>其中各个字段的含义说明如下：<br><br>1)&nbsp; REDIS：常量，保存着&rdquo;REDIS&rdquo;5个字符。<br><br>2)&nbsp; db_version：RDB文件的版本号，注意不是Redis的版本号。<br><br>3)&nbsp; SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。<br><br>4)&nbsp; EOF：常量，标志RDB文件正文内容结束。<br><br>5)&nbsp; check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。<br><br><strong>压缩</strong><br><br>Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090239365-13188208.png" alt><br><br>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。<br><br>## <a name="t34"></a>4. 启动时加载<br><br>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。<br><br>Redis启动日志中可以看到自动载入的执行：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605090316297-2056098245.png" alt><br><br>Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。<br><br>## <a name="t35"></a>5. RDB常用配置总结<br><br>下面是RDB常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。<br><br><em>   save m n：bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发
</em>   stop-writes-on-bgsave-error yes：当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no<br><em>   rdbcompression yes：是否开启RDB文件压缩
</em>   rdbchecksum yes：是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现<br><em>   dbfilename dump.rdb：RDB文件名
</em>   dir ./：RDB文件和AOF文件所在目录<br><br># <a name="t4"></a>四、AOF持久化<br><br>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。<br><br>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。<br><br>## <a name="t41"></a>1. 开启AOF<br><br>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：<br><br>appendonly yes<br><br>## <a name="t42"></a>2. 执行流程<br><br>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。<br><br>AOF的执行流程包括：<br><br><em>   命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；
</em>   文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；<br><em>   文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。<br><br>### 1) 命令追加(append)<br><br>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。<br><br>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。<br><br>### 2) 文件写入(write)和文件同步(sync)<br><br>Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：<br><br>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。<br><br>&nbsp;<br><br>AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：

</em>   always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。<br><em>   no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。
</em>   everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<strong><span style="line-height: 1.5;">everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。</span></strong><br><br>### 3) 文件重写(rewrite)<br><br>随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。<br><br>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，<strong>AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</strong><br><br>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。<br><br>&nbsp;<br><br>文件重写之所以能够压缩AOF文件，原因在于：<br><br><em>   过期的数据不再写入文件
</em>   无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等<br><em>   多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091657431-1777000468.png" alt><br><br>通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。<br><br><strong>文件重写的触发</strong><br><br>文件重写的触发，分为手动触发和自动触发：<br><br>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091720655-1144425871.png" alt><br><br>此时服务器执行日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091728855-1220695695.png" alt><br><br>&nbsp;<br><br>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。

</em>   auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。<br><em>   auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。<br><br>其中，参数可以通过config get命令查看：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091826619-1149439298.png" alt><br><br>状态可以通过info persistence查看：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091913978-93129453.png" alt><br><br><span style="line-height: 1.5;">只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</span><br><br>自动触发bgrewriteaof时，可以看到服务器日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605091932313-1279644027.png" alt><br><br><strong>文件重写的流程</strong><br><br>文件重写流程如下图所示(图片来源：<a href="http://www.cnblogs.com/yangmingxianshen/p/8373205.html)：" target="_blank" rel="noopener">http://www.cnblogs.com/yangmingxianshen/p/8373205.html)：</a><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605092001589-1724580361.png" alt><br><br>关于文件重写的流程，有两点需要特别注意：(1)重写由父进程fork子进程进行；(2)重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了aof_rewrite_buf缓存。<br><br>对照上图，文件重写的流程如下：<br><br>1) Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br><br>2) 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。<br><br>3.1) 父进程fork后，bgrewriteaof命令返回&rdquo;Background append only file rewrite started&rdquo;信息并不再阻塞父进程，并可以响应其他命令。<strong>Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。</strong><br><br>3.2) 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。<strong>由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</strong><br><br>4) 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。<br><br>5.1) 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。<br><br>5.2) 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br><br>5.3) 使用新的AOF文件替换老文件，完成AOF重写。<br><br>## <a name="t43"></a>3. 启动时加载<br><br>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。<br><br>当AOF开启，且AOF文件存在时，Redis启动日志：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125715427-372924099.png" alt><br><br>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)，Redis启动日志如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125726244-1151986629.png" alt><br><br><strong>文件校验</strong><br><br>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605125752302-1021481114.png" alt><br><br><strong>伪客户端</strong><br><br>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。<br><br>## <a name="t44"></a>4. AOF常用配置总结<br><br>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。

</em>   appendonly no：是否开启AOF<br><em>   appendfilename “appendonly.aof”：AOF文件名
</em>   dir ./：RDB文件和AOF文件所在目录<br><em>   appendfsync everysec：fsync持久化策略
</em>   no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡<br><em>   auto-aof-rewrite-percentage 100：文件重写触发条件之一
</em>   auto-aof-rewrite-min-size 64mb：文件重写触发提交之一<br><em>   aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件<br><br># <a name="t5"></a>五、方案选择与常见问题<br><br>前面介绍了RDB和AOF两种持久化方案的细节，下面介绍RDB和AOF的特点、如何选择持久化方案，以及在持久化过程中常遇到的问题等。<br><br>## <a name="t51"></a>1. RDB和AOF的优缺点<br><br>RDB和AOF各有优缺点：<br><br><strong>RDB持久化</strong><br><br>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。<br><br>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。<br><br><strong>AOF持久化</strong><br><br>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。<br><br>## <a name="t52"></a>2. 持久化策略选择<br><br>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。<br><br>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。<br><br>&nbsp;<br><br>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。<br><br>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。<br><br>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。<br><br>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。<br><br>在这种情况下，一种可行的做法是：<br><br>master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好<br><br>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。<br><br>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：

</em>   master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。<br><em>   master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免&ldquo;自动拉起机制&rdquo;和&ldquo;不做持久化&rdquo;同时出现。<br><br>（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。<br><br>## <a name="t53"></a>3. fork阻塞：CPU的阻塞<br><br>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：

</em>   当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；<br><em>   当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；
</em>   以及持久化过程中的fork操作，下面详细说明。<br><br>首先说明一下fork操作：<br><br>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。<br><br>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。<br><br>&nbsp;<br><br>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。<br><br>对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。<br><br>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。<br><br>## <a name="t54"></a>4. AOF追加阻塞：硬盘的阻塞<br><br>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。<br><br>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。<br><br>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。<br><br>&nbsp;<br><br>AOF追加阻塞问题定位的方法：<br><br>（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。<br><br>（2）AOF阻塞时的Redis日志：<br><br>Asynchronous&nbsp;AOF&nbsp;fsync&nbsp;is&nbsp;taking&nbsp;too&nbsp;long&nbsp;(disk&nbsp;is&nbsp;busy?).&nbsp;Writing&nbsp;the&nbsp;AOF&nbsp;buffer&nbsp;without&nbsp;waiting&nbsp;for&nbsp;fsync&nbsp;to&nbsp;complete,&nbsp;this&nbsp;may&nbsp;slow&nbsp;down&nbsp;Redis.<br><br>（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。<br><br>## <a name="t55"></a>5. info命令与持久化<br><br>前面提到了一些通过info命令查看持久化相关状态的方法，下面来总结一下。<br><br>（1）info Persistence<br><br>执行结果如下：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180605131816242-1924276636.png" alt><br><br>其中比较重要的包括：<br><br><em>   rdb_last_bgsave_status:上次bgsave 执行结果，可以用于发现bgsave错误
</em>   rdb_last_bgsave_time_sec:上次bgsave执行时间（单位是s），可以用于发现bgsave是否耗时过长<br><em>   aof_enabled:AOF是否开启
</em>   aof_last_rewrite_time_sec: 上次文件重写执行时间（单位是s），可以用于发现文件重写是否耗时过长<br><em>   aof_last_bgrewrite_status: 上次bgrewrite执行结果，可以用于发现bgrewrite错误
</em>   aof_buffer_length和aof_rewrite_buffer_length:aof缓存区大小和aof重写缓冲区大小<br>*   aof_delayed_fsync:AOF追加阻塞情况的统计<br><br>（2）info stats<br><br>其中与持久化关系较大的是：latest_fork_usec，代表上次fork耗时，可以参见前面的讨论。<br><br># <a name="t6"></a>六、总结<br><br>本文主要内容可以总结如下：<br><br>1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。<br><br>2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。<br><br>3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。<br><br>4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。<br><br># 参考文献<br><br>《Redis开发与运维》<br><br>《Redis设计与实现》<br><br>《Redis实战》<br><br><a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">http://www.redis.cn/topics/persistence.html</a><br><br><a href="https://mp.weixin.qq.com/s/fpupqLp-wjR8fQvYSQhVLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fpupqLp-wjR8fQvYSQhVLg</a><br><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650764050&amp;idx=1&amp;sn=891287b9f99a8c1dd4ce9e1805646741&amp;chksm=f3f9c687c48e4f91c6631e7f5e36a9169c10549386bec541dbeef92ed0023a373f6ec25c2ef1&amp;mpshare=1&amp;scene=1&amp;srcid=0525xnHQxiFwpzFWSME2LQrb#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650764050&amp;idx=1&amp;sn=891287b9f99a8c1dd4ce9e1805646741&amp;chksm=f3f9c687c48e4f91c6631e7f5e36a9169c10549386bec541dbeef92ed0023a373f6ec25c2ef1&amp;mpshare=1&amp;scene=1&amp;srcid=0525xnHQxiFwpzFWSME2LQrb#rd</a><br><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650763383&amp;idx=1&amp;sn=348a84605a7cdefe4e075c9f0310f257&amp;chksm=f3f9c5e2c48e4cf41bd3f708bce3f9a1302a699cf7defe611e9aea120fcb424944119e079362&amp;mpshare=1&amp;scene=1&amp;srcid=0525XIl8KXvHYvX42oaUcop0#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650763383&amp;idx=1&amp;sn=348a84605a7cdefe4e075c9f0310f257&amp;chksm=f3f9c5e2c48e4cf41bd3f708bce3f9a1302a699cf7defe611e9aea120fcb424944119e079362&amp;mpshare=1&amp;scene=1&amp;srcid=0525XIl8KXvHYvX42oaUcop0#rd</a><br><br><a href="https://blog.csdn.net/tonyxf121/article/details/8475603" target="_blank" rel="noopener">https://blog.csdn.net/tonyxf121/article/details/8475603</a><br><br><a href="http://heylinux.com/archives/1932.html" target="_blank" rel="noopener">http://heylinux.com/archives/1932.html</a><br><br><a href="https://www.m690.com/archives/380/" target="_blank" rel="noopener">https://www.m690.com/archives/380/</a><br>            </div><!--end: forFlow --><br>        </div><!--end: mainContent 主体内容容器--><br>        <div class="clear"></div><br>    </div><!--end: main --><br>    <div class="clear"></div><br></div><!--end: home 自定义的最大容器 --><br><br></body><br></html>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/06/13/Redis内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/13/Redis内存模型/" class="post-title-link" itemprop="url">Redis内存模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-13 10:24:23" itemprop="dateCreated datePublished" datetime="2019-06-13T10:24:23+08:00">2019-06-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/13/Redis内存模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/13/Redis内存模型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&lt;!DOCTYPE html&gt;</p>
<html lang="zh-cn"><br><body><br><!--done--><br><div id="home"><br><br>## 前言<br><br>Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。<br><br>我们使用Redis时，会接触Redis的5种对象类型（字符串、哈希、列表、集合、有序集合），丰富的类型是Redis相对于Memcached等的一大优势。在了解Redis的5种对象类型的用法和特点的基础上，进一步了解Redis的内存模型，对Redis的使用有很大帮助，例如：<br><br>1、估算Redis内存使用量。目前为止，内存的使用成本仍然相对较高，使用内存不能无所顾忌；根据需求合理的评估Redis的内存使用量，选择合适的机器配置，可以在满足需求的情况下节约成本。<br><br>2、优化内存占用。了解Redis内存模型可以选择更合适的数据类型和编码，更好的利用Redis内存。<br><br>3、分析解决问题。当Redis出现阻塞、内存占用等问题时，尽快发现导致问题的原因，便于分析解决问题。<br><br>这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。<br><br>在后面的文章中，会陆续介绍关于Redis高可用的内容，包括主从复制、哨兵、集群等等，欢迎关注。<br><br>## 系列文章<br><br><a href="https://www.cnblogs.com/kismetv/p/8654978.html" target="_blank" rel="noopener">深入学习Redis（1）：Redis内存模型</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a><br><br><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a><br><br>## 目录<br><br><a href="#t1">一、Redis内存统计</a><br><br><a href="#t2">二、Redis内存划分</a><br><br>　　<a href="#t21">1、数据（或者称为对象）</a><br><br>　　<a href="#t22">2、进程本身运行需要的内存</a><br><br>　　<a href="#t23">3、缓冲内存</a><br><br>　　<a href="#t24">4、内存碎片</a><br><br><a href="#t3">三、Redis数据存储的细节</a><br><br>　　<a href="#t31">1、概述</a><br><br>　　<a href="#t32">2、jemalloc</a><br><br>　　<a href="#t33">3、redisObject</a><br><br>　　<a href="#t34">4、SDS</a><br><br><a href="#t4">四、Redis的对象类型与内部编码</a><br><br>　　<a href="#t41">1、字符串</a><br><br>　　<a href="#t42">2、列表</a><br><br>　　<a href="#t43">3、哈希</a><br><br>　　<a href="#t44">4、集合</a><br><br>　　<a href="#t45">5、有序集合</a><br><br><a href="#t5">五、应用举例</a><br><br>　　<a href="#t51">1、估算Redis内存使用量</a><br><br>　　<a href="#t52">2、优化内存占用</a><br><br>　　<a href="#t53">3、关注内存碎片率</a><br><br><a href="#t6">六、参考文献</a><br><br># <a name="t1"></a>一、Redis内存统计<br><br>工欲善其事必先利其器，在说明Redis内存之前首先说明如何统计Redis使用内存的情况。<br><br>在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:bash;gutter:true;">info memory</pre><br></div><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327000947752-2103814952.png" alt><br><br>其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。<br><br>返回结果中比较重要的几个说明如下：<br><br>（1）<strong>used_memory**</strong>：<strong>Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。<br><br>（2）</strong>used_memory_rss<strong>**：</strong>Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。<br><br>因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。<br><br>由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。<br><br>（3）<strong>mem_fragmentation_ratio**</strong>：<strong>内存碎片比率，该值是used_memory_rss / used_memory的比值。<br><br>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。<br><br>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；上面截图中的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。<br><br>（4）</strong>mem_allocator<strong>**：</strong>Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。<br><br># <a name="t2"></a>二、Redis内存划分<br><br>Redis作为内存数据库，在内存中存储的内容主要是数据（键值对）；通过前面的叙述可以知道，除了数据以外，Redis的其他部分也会占用内存。<br><br>Redis的内存占用主要可以划分为以下几个部分：<br><br>## <a name="t21"></a>1、数据<br><br>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。<br><br>Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。<br><br>## <a name="t22"></a>2、进程本身运行需要的内存<br><br>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。<br><br>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。<br><br>## <a name="t23"></a>3、缓冲内存<br><br>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。<br><br>## <a name="t24"></a>4、内存碎片<br><br>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。<br><br>内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。<br><br>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。<br><br># <a name="t3"></a>三、Redis数据存储的细节<br><br>## <a name="t31"></a>1、概述<br><br>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。<br><br>下图是执行set hello world时，所涉及到的数据模型。<br><br>&nbsp;<img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001055927-1896197804.png" alt><br><br>图片来源：<a href="https://searchdatabase.techtarget.com.cn/7-20218/" target="_blank" rel="noopener">https://searchdatabase.techtarget.com.cn/7-20218/</a><br><br>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。<br><br>（2）Key：图中右上角可见，Key（&rdquo;hello&rdquo;）并不是直接以字符串存储，而是存储在SDS结构中。<br><br>（3）redisObject：Value(&ldquo;world&rdquo;)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。<br><br>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。<br><br>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。<br><br>下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。<br><br>## <a name="t32"></a>2、jemalloc<br><br>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。<br><br>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。<br><br>jemalloc划分的内存单元如下图所示：<br><br>&nbsp;<img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001126509-2023165562.png" alt><br><br><span style="line-height: 1.5;">图片来源：<a href="http://blog.csdn.net/zhengpeitao/article/details/76573053" target="_blank" rel="noopener">http://blog.csdn.net/zhengpeitao/article/details/76573053</a></span><br><br>例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。<br><br>## <a name="t33"></a>3、redisObject<br><br>前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。<br><br>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。<br><br>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct redisObject {<br>　　unsigned type:4;<br>　　unsigned encoding:4;<br>　　unsigned lru:REDIS_LRU_BITS; /<em> lru time (relative to server.lruclock) </em>/<br>　　int refcount;<br>　　void <em>ptr;<br>} robj;</em></pre><br></div><br><br>redisObject的每个字段的含义和作用如下：<br><br>### （1）type<br><br>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。<br><br>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001214189-1733420705.png" alt><br><br>### （2）encoding<br><br>encoding表示对象的内部编码，占4个比特。<br><br>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。<br><br>通过object encoding命令，可以查看对象采用的编码方式，如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001228807-998910409.png" alt><br><br>5种对象类型对应的编码方式以及使用条件，将在后面介绍。<br><br>### （3）lru<br><br>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。<br><br>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001239788-1325383307.png" alt><br><br>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys&mdash;lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。<br><br>### （4）refcount<br><br><strong>refcount**</strong>与共享对象<strong><br><br>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。<br><br>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。

</strong>共享对象的具体实现**<br><br>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。<br><br>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。<br><br>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0~9999的整数值；当Redis需要使用值为0~9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。<br><br>共享对象的引用次数可以通过object refcount命令查看，如下图所示。命令执行的结果页佐证了只有0~9999之间的整数会作为共享对象。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001256958-1309209644.png" alt><br><br>### （5）ptr<br><br>ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。<br><br>### （6）总结<br><br>综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：<br><br>4bit+4bit+24bit+4Byte+8Byte=16Byte。<br><br>## <a name="t34"></a>4、SDS<br><br>Redis没有直接使用C字符串(即以空字符&rsquo;\0&rsquo;结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。<br><br>### （1）SDS结构<br><br>sds的结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">struct sdshdr {<br>    int len;<br>    int free;<br>    char buf[];<br>};</pre><br></div><br><br>其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001321434-1043595793.png" alt><br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001325561-890602831.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。<br><br>### （2）SDS与C字符串的比较<br><br>SDS在C字符串的基础上加入了free和len字段，带来了很多好处：

   获取字符串长度：SDS是O(1)，C字符串是O(n)<br><em>   缓冲区溢出：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。
</em>   修改字符串时内存的重分配：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化：空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。<br><em>   存取二进制数据：SDS可以，C字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。<br><br>此外，由于SDS中的buf仍然使用了C字符串（即以&rsquo;\0&rsquo;结尾），因此SDS可以使用C字符串库中的部分函数；但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（&rsquo;\0&rsquo;不一定是结尾）。<br><br>### （3）SDS与C字符串的应用<br><br>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（&rdquo;myset&rdquo;），还是集合中的元素（&rdquo;member1&rdquo;、 &rdquo;member2&rdquo;和&rdquo;member3&rdquo;），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。<br><br>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。<br><br># <a name="t4"></a>四、Redis的对象类型与内部编码<br><br>前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。<br><br>Redis各种对象类型支持的内部编码如下图所示(图中版本是Redis3.0，Redis后面版本中又增加了内部编码，略过不提；本章所介绍的内部编码都是基于3.0的)：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001358239-1304238510.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>关于Redis内部编码的转换，都符合以下规律：<strong>编码转换在**</strong>Redis<strong>**写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</strong><br><br>## <a name="t41"></a>1、字符串<br><br>### （1）概况<br><br>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。<br><br>字符串长度不能超过512MB。<br><br>### （2）内部编码<br><br>字符串类型的内部编码有3种，它们的应用场景如下：

</em>   int：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。<br><em>   embstr：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。
</em>   raw：大于39个字节的字符串<br><br>示例如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001417703-15851809.png" alt><br><br>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。<br><br>### （3）编码转换<br><br>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。<br><br>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。示例如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001426651-1225081171.png" alt><br><br>## <a name="t42"></a>2、列表<br><br>### （1）概况<br><br>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。<br><br>### （2）内部编码<br><br>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。<br><br>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001435577-242733744.png" alt><br><br>图片来源：《Redis设计与实现》<br><br>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。<br><br>&nbsp;<br><br>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的<strong>连续内存块</strong>(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。<br><br>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。<br><br>下图展示了列表编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001457636-673470263.png" alt><br><br>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。<br><br>## <a name="t43"></a>3、哈希<br><br>### （1）概况<br><br>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用&ldquo;内层的哈希&rdquo;时，代表的是redis对外提供的5种对象类型的一种；使用&ldquo;外层的哈希&rdquo;代指Redis作为Key-Value数据库所使用的数据结构。<br><br>### （2）内部编码<br><br>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。<br><br>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。<br><br>&nbsp;<br><br>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。<br><br>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001627028-325473621.png" alt>&nbsp;<br><br>图片改编自：《Redis设计与实现》<br><br>下面从底层向上依次介绍各个部分：<br><br><strong>dictEntry</strong><br><br>dictEntry结构用于保存键值对，结构定义如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dictEntry{<br>    void <em>key;<br>    union{<br>        void </em>val;<br>        uint64_tu64;<br>        int64_ts64;<br>    }v;<br>    struct dictEntry <em>next;<br>}dictEntry;</em></pre><br></div><br><br>其中，各个属性的功能如下：

   key：键值对中的键；<br><em>   val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；
</em>   next：指向下一个dictEntry，用于解决哈希冲突问题<br><br>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。<br><br><strong>bucket</strong><br><br>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。<br><br><strong>dictht</strong><br><br>dictht结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dictht{<br>    dictEntry <strong>table;<br>    unsigned long size;<br>    unsigned long sizemask;<br>    unsigned long used;<br>}dictht;</strong></pre><br></div><br><br>其中，各个属性的功能说明如下：<br><br><em>   table属性是一个指针，指向bucket；
</em>   size属性记录了哈希表的大小，即bucket的大小；<br><em>   used记录了已使用的dictEntry的数量；
</em>   sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。

dict*<em><br><br>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。<br><br>dict结构如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct dict{<br>    dictType </pre></div></em>type;<br>    void <em>privdata;<br>    dictht ht[2];<br>    int trehashidx;<br>} dict;<br></em></div><br><br>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。<br><br>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。<br><br>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。<br><br>### （3）编码转换<br><br>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。<br><br>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。<br><br>下图展示了Redis内层的哈希编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001855681-1566128865.png" alt><br><br>## <a name="t44"></a>4、集合<br><br>### （1）概况<br><br>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。<br><br>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。<br><br>### （2）内部编码<br><br>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。<br><br>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。<br><br>整数集合的结构定义如下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">typedef struct intset{<br>    uint32_t encoding;<br>    uint32_t length;<br>    int8_t contents[];<br>} intset;</pre><br></div><br><br>其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。<br><br>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(1)变为了O(n)，但由于集合数量较少，因此操作的时间并没有明显劣势。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。<br><br>下图展示了集合编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001926146-2105183556.png" alt><br><br>## <a name="t45"></a>5、有序集合<br><br>### （1）概况<br><br>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。<br><br>### （2）内部编码<br><br>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。<br><br>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。<br><br>### （3）编码转换<br><br>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。<br><br>下图展示了有序集合编码转换的特点：<br><br><img src="https://images2018.cnblogs.com/blog/1174710/201803/1174710-20180327001936290-955216194.png" alt><br><br># <a name="t5"></a>五、应用举例<br><br>了解Redis的内存模型之后，下面通过几个例子说明其应用。<br><br>## <a name="t51"></a>1、估算Redis内存使用量<br><br>要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。<br><br>下面以最简单的字符串类型来进行说明。<br><br>假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。<br><br>90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。<br><br>每个dictEntry占据的空间包括：<br><br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个dictEntry，24字节，jemalloc会分配32字节的内存块<br><br>2) &nbsp; &nbsp; &nbsp;&nbsp;一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块<br><br>3) &nbsp; &nbsp; &nbsp;&nbsp;一个redisObject，16字节，jemalloc会分配16字节的内存块<br><br>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块<br><br>5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 综上，一个dictEntry需要32+16+16+16=80个字节。<br><br>bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。<br><br>因此，可以估算出这90000个键值对占据的内存大小为：9000080 + 131072<em>8 = 8248576。<br><br>下面写个程序在redis中验证一下：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">public class RedisTest {<br><br>　　public static Jedis jedis = new Jedis(“localhost”, 6379);<br><br>　　public static void main(String[] args) throws Exception{<br>　　　　Long m1 = Long.valueOf(getMemory());<br>　　　　insertData();<br>　　　　Long m2 = Long.valueOf(getMemory());<br>　　　　System.out.println(m2 - m1);<br>　　}<br><br>　　public static void insertData(){<br>　　　　for(int i = 10000; i &lt; 100000; i++){<br>　　　　　　jedis.set(“aa” + i, “aa” + i); //key和value长度都是7字节，且不是整数<br>　　　　}<br>　　}<br><br>　　public static String getMemory(){<br>　　　　String memoryAllLine = jedis.info(“memory”);<br>　　　　String usedMemoryLine = memoryAllLine.split(“\r\n”)[1];<br>　　　　String memory = usedMemoryLine.substring(usedMemoryLine.indexOf(‘:’) + 1);<br>　　　　return memory;<br>　　}<br>}</pre><br></div><br><br>运行结果：8247552<br><br>理论值与结果值误差在万分之1.2，对于计算需要多少内存来说，这个精度已经足够了。之所以会存在误差，是因为在我们插入90000条数据之前redis已分配了一定的bucket空间，而这些bucket空间尚未使用。<br><br>&nbsp;<br><br>作为对比将key和value的长度由7字节增加到8字节，则对应的SDS变为17个字节，jemalloc会分配32个字节，因此每个dictEntry占用的字节数也由80字节变为112字节。此时估算这90000个键值对占据内存大小为：90000</em>112 + 131072*8 = 11128576。<br><br>在redis中验证代码如下（只修改插入数据的代码）：<br><br><div class="cnblogs_Highlighter"><br><pre class="brush:cpp;gutter:true;">public static void insertData(){<br>　　for(int i = 10000; i &lt; 100000; i++){<br>　　　　jedis.set(“aaa” + i, “aaa” + i); //key和value长度都是8字节，且不是整数<br>　　}<br>}</pre><br></div><br><br>运行结果：11128576；估算准确。<br><br>&nbsp;<br><br>对于字符串类型之外的其他类型，对内存占用的估算方法是类似的，需要结合具体类型的编码方式来确定。<br><br>## <a name="t52"></a>2、优化内存占用<br><br>了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。<br><br>（1）利用jemalloc特性进行优化<br><br>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。<br><br>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。<br><br>（2）使用整型/长整型<br><br>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。<br><br>（3）共享对象<br><br>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。<br><br>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。<br><br>（4）避免过度设计<br><br>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。<br><br>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。<br><br>## <a name="t53"></a>3、关注内存碎片率<br><br>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。<br><br>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。<br><br>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。<br><br>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。<br><br># <a name="t6"></a>六、参考文献<br><br>《Redis开发与运维》<br><br>《Redis设计与实现》<br><br><a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a><br><br><a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a><br><br><a href="https://www.cnblogs.com/lhcpig/p/4769397.html" target="_blank" rel="noopener">https://www.cnblogs.com/lhcpig/p/4769397.html</a><br><br><a href="https://searchdatabase.techtarget.com.cn/7-20218/" target="_blank" rel="noopener">https://searchdatabase.techtarget.com.cn/7-20218/</a><br><br><a href="http://www.cnblogs.com/mushroom/p/4738170.html" target="_blank" rel="noopener">http://www.cnblogs.com/mushroom/p/4738170.html</a><br><br><a href="http://www.imooc.com/article/3645" target="_blank" rel="noopener">http://www.imooc.com/article/3645</a><br><br><a href="http://blog.csdn.net/zhengpeitao/article/details/76573053" target="_blank" rel="noopener">http://blog.csdn.net/zhengpeitao/article/details/76573053</a><br></body><br></html>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/" class="post-title-link" itemprop="url">ThreadLocal及ThreadLocal内存溢出分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-24 13:21:05" itemprop="dateCreated datePublished" datetime="2019-05-24T13:21:05+08:00">2019-05-24</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://47.103.200.134/image/p15.jpg" alt></p>
<h3 id="ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露"><a href="#ThreadLocal-定义，以及是否可能引起的内存泄露-threadlocalMap的Key是弱引用，用线程池有可能泄露" class="headerlink" title="ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)"></a>ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露)</h3><p>ThreadLocal 也可以跟踪一个请求，从接收请求，处理请求，到返回请求，只要线程不销毁，就可以在线程的任何地方，调用这个参数，这是百度二面的题目，参考：<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/24/ThreadLocal及ThreadLocal内存溢出分析/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/24/内存溢出-栈溢出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/24/内存溢出-栈溢出/" class="post-title-link" itemprop="url">内存溢出&&栈溢出</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-24 10:02:54" itemprop="dateCreated datePublished" datetime="2019-05-24T10:02:54+08:00">2019-05-24</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/24/内存溢出-栈溢出/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/24/内存溢出-栈溢出/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="内存溢出-amp-amp-栈溢出"><a href="#内存溢出-amp-amp-栈溢出" class="headerlink" title="内存溢出&amp;&amp;栈溢出"></a>内存溢出&amp;&amp;栈溢出</h3><p><img src="http://47.103.200.134/image/p5.jpg" alt></p>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/24/内存溢出-栈溢出/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/23/并发编程之线程安全性、安全发布对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/23/并发编程之线程安全性、安全发布对象/" class="post-title-link" itemprop="url">并发编程之线程安全性、安全发布对象</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-23 23:04:38" itemprop="dateCreated datePublished" datetime="2019-05-23T23:04:38+08:00">2019-05-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/23/并发编程之线程安全性、安全发布对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/23/并发编程之线程安全性、安全发布对象/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><img src="http://47.103.200.134/image/p6.jpg" alt><br>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就称这个类是线程安全的。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/23/并发编程之线程安全性、安全发布对象/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/23/CPU缓存一致性协议MESI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/23/CPU缓存一致性协议MESI/" class="post-title-link" itemprop="url">CPU缓存一致性协议MESI</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-23 11:40:52" itemprop="dateCreated datePublished" datetime="2019-05-23T11:40:52+08:00">2019-05-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/23/CPU缓存一致性协议MESI/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/23/CPU缓存一致性协议MESI/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://47.103.200.134/image/p3.jpg" alt="输入图片说明"></p>
<h3 id="CPU高速缓存（Cache-Memory）"><a href="#CPU高速缓存（Cache-Memory）" class="headerlink" title="CPU高速缓存（Cache Memory）"></a>CPU高速缓存（Cache Memory）</h3><h4 id="CPU为何要有高速缓存"><a href="#CPU为何要有高速缓存" class="headerlink" title="CPU为何要有高速缓存"></a>CPU为何要有高速缓存</h4><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/23/CPU缓存一致性协议MESI/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/23/内存屏障/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/23/内存屏障/" class="post-title-link" itemprop="url">内存屏障</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-23 10:29:38" itemprop="dateCreated datePublished" datetime="2019-05-23T10:29:38+08:00">2019-05-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/23/内存屏障/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/23/内存屏障/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://47.103.200.134/image/p2.jpg" alt="输入图片说明"></p>
<h4 id="为什么会有内存屏障"><a href="#为什么会有内存屏障" class="headerlink" title="为什么会有内存屏障"></a>为什么会有内存屏障</h4><ul>
<li>每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取。但是这样的弊端也很明显：不能实时的和内存发生信息交换，分在不同CPU执行的不同线程对同一个变量的缓存值不同。</li>
<li>用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令。
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/23/内存屏障/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </li></ul></div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/23/LongAdder解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/23/LongAdder解析/" class="post-title-link" itemprop="url">LongAdder解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-23 08:14:41" itemprop="dateCreated datePublished" datetime="2019-05-23T08:14:41+08:00">2019-05-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/23/LongAdder解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/23/LongAdder解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="LongAdder解析"><a href="#LongAdder解析" class="headerlink" title="LongAdder解析"></a>LongAdder解析</h3><p><img src="http://47.103.200.134/image/p1.jpg" alt="输入图片说明"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘要： 对`LongAdder`的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于`AtomicLong`来说，更加适合写多读少的并发情景。今天，我们就研究一下`LongAdder`的原理，探究一下它如此高效的原因。</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/23/LongAdder解析/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/22/java并发计数器分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/22/java并发计数器分析/" class="post-title-link" itemprop="url">java并发计数器分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-22 19:04:00" itemprop="dateCreated datePublished" datetime="2019-05-22T19:04:00+08:00">2019-05-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/22/java并发计数器分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/22/java并发计数器分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://47.103.200.134/image/p12.jpg" alt></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><pre><code>一提到线程安全的并发计数器，AtomicLong 必然是第一个被联想到的工具。Atomic* 一系列的原子类以及它们背后的 CAS 无锁算法，常常是高性能，高并发的代名词。本文将会阐释，在并发场景下，使用 AtomicLong 来充当并发计数器将会是一个糟糕的设计，实际上存在不少 AtomicLong 之外的计数器方案。近期我研究了一些 Jdk1.8 以及 JCTools 的优化方案，并将它们的对比与实现细节整理于此。
</code></pre>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/22/java并发计数器分析/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.zengmanhua.cn/2019/05/21/并发编程之基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Yu Bao">
      <meta itemprop="description" content="生活源于奋斗">
      <meta itemprop="image" content="http://prl6c63q7.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinYuBao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/21/并发编程之基础知识/" class="post-title-link" itemprop="url">并发编程之基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-21 15:11:40" itemprop="dateCreated datePublished" datetime="2019-05-21T15:11:40+08:00">2019-05-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/21/并发编程之基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/21/并发编程之基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="Lombox"><a href="#Lombox" class="headerlink" title="Lombox"></a>Lombox</h3><p><img src="http://47.103.200.134/image/p13.jpg" alt></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Lombok项目是一个java库，可以自动插入到您的编辑器和构建工具中，让您的java变得更加精彩。切勿再次写入另一个getter或equals方法。提前访问未来的Java功能val，等等。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/05/21/并发编程之基础知识/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image" src="http://prl6c63q7.bkt.clouddn.com/avatar.jpg" alt="Jin Yu Bao">
                </a>
            
              <p class="site-author-name" itemprop="name">Jin Yu Bao</p>
              <div class="site-description motion-element" itemprop="description">生活源于奋斗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/jinyubao" title="GitHub &rarr; https://github.com/jinyubao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:1345551624@qq.com" title="E-Mail &rarr; mailto:1345551624@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                -- 推荐浏览网址 --
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.github.com" title="https://www.github.com" rel="noopener" target="_blank">Github</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.zhihu.com" title="https://www.zhihu.com" rel="noopener" target="_blank">知乎</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.uisdc.com" title="http://www.uisdc.com" rel="noopener" target="_blank">优设</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com" title="https://www.jianshu.com" rel="noopener" target="_blank">简书</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net" title="https://blog.csdn.net" rel="noopener" target="_blank">CSDN</a>
                  </li>
                
              </ul>
              <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("05/18/2019 13:47:14");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>

            </div>
          
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=455556558&auto=1&height=66"></iframe>
          
            
          
          <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("05/18/2019 13:47:14");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin Yu Bao</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'TRcVmXJ17nlU8oUlreTjl64y-gzGzoHsz',
    appKey: 'KTptYJdVQ4QJDnIEuFl9YVAv',
    placeholder: 'Just go go',
    avatar: 'wavatar',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
